[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISL",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "chapter2.html",
    "href": "chapter2.html",
    "title": "chapter2",
    "section": "",
    "text": "In this lab, we will introduce some simple R commands. The best way to learn a new language is to try out the commands. R can be downloaded from\nhttp://cran.r-project.org/\nWe recommend that you run R within an integrated development environment (IDE) such as RStudio, which can be freely downloaded from\nhttp://rstudio.com\nThe RStudio website also provides a cloud-based version of R, which does not require installing any software.\n\n\nR uses functions to perform operations. To run a function called funcname, we type funcname(input1, input2), where the inputs (or arguments) input1 and input2 tell R how to run the function. A function can have any number of inputs. For example, to create a vector of numbers, we use the function c() (for concatenate). Any numbers inside the parentheses are joined together. The following command instructs R to join together the numbers 1, 3, 2, and 5, and to save them as a vector named x. When we type x, it gives us back the vector.\n\nx &lt;- c(1, 3, 2, 5)\nx\n\n[1] 1 3 2 5\n\n\nNote that the &gt; is not part of the command; rather, it is printed by R to indicate that it is ready for another command to be entered. We can also save things using = rather than &lt;-:\n\nx = c(1, 6, 2)\nx\n\n[1] 1 6 2\n\ny = c(1, 4, 3)\n\nHitting the up arrow multiple times will display the previous commands, which can then be edited. This is useful since one often wishes to repeat a similar command. In addition, typing ?funcname will always cause R to open a new help file window with additional information about the function funcname().\nWe can tell R to add two sets of numbers together. It will then add the first number from x to the first number from y, and so on. However, x and y should be the same length. We can check their length using the length() function.\n\nlength(x)\n\n[1] 3\n\nlength(y)\n\n[1] 3\n\nx + y\n\n[1]  2 10  5\n\n\nThe ls() function allows us to look at a list of all of the objects, such as data and functions, that we have saved so far. The rm() function can be used to delete any that we don’t want.\n\nls()\n\n[1] \"x\" \"y\"\n\nrm(x, y)\nls()\n\ncharacter(0)\n\n\nIt’s also possible to remove all objects at once:\n\nrm(list = ls())\n\nThe matrix() function can be used to create a matrix of numbers. Before we use the matrix() function, we can learn more about it:\n\n?matrix\n\nstarting httpd help server ... done\n\n\nThe help file reveals that the matrix() function takes a number of inputs, but for now we focus on the first three: the data (the entries in the matrix), the number of rows, and the number of columns. First, we create a simple matrix.\n\nx &lt;- matrix(data = c(1, 2, 3, 4), nrow = 2, ncol = 2)\nx\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\nNote that we could just as well omit typing data=, nrow=, and ncol= in the matrix() command above: that is, we could just type\n\nx &lt;- matrix(c(1, 2, 3, 4), 2, 2)\n\nand this would have the same effect. However, it can sometimes be useful to specify the names of the arguments passed in, since otherwise R will assume that the function arguments are passed into the function in the same order that is given in the function’s help file. As this example illustrates, by default R creates matrices by successively filling in columns. Alternatively, the byrow = TRUE option can be used to populate the matrix in order of the rows.\n\nmatrix(c(1, 2, 3, 4), 2, 2, byrow = TRUE)\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n\n\nNotice that in the above command we did not assign the matrix to a value such as x. In this case the matrix is printed to the screen but is not saved for future calculations. The sqrt() function returns the square root of each element of a vector or matrix. The command x^2 raises each element of x to the power 2; any powers are possible, including fractional or negative powers.\n\nsqrt(x)\n\n         [,1]     [,2]\n[1,] 1.000000 1.732051\n[2,] 1.414214 2.000000\n\nx^2\n\n     [,1] [,2]\n[1,]    1    9\n[2,]    4   16\n\n\nThe rnorm() function generates a vector of random normal variables, with first argument n the sample size. Each time we call this function, we will get a different answer. Here we create two correlated sets of numbers, x and y, and use the cor() function to compute the correlation between them.\n\nx &lt;- rnorm(50)\ny &lt;- x + rnorm(50, mean = 50, sd = .1)\ncor(x, y)\n\n[1] 0.994796\n\n\nBy default, rnorm() creates standard normal random variables with a mean of \\(0\\) and a standard deviation of \\(1\\). However, the mean and standard deviation can be altered using the mean and sd arguments, as illustrated above. Sometimes we want our code to reproduce the exact same set of random numbers; we can use the set.seed() function to do this. The set.seed() function takes an (arbitrary) integer argument.\n\nset.seed(1303)\nrnorm(50)\n\n [1] -1.1439763145  1.3421293656  2.1853904757  0.5363925179  0.0631929665\n [6]  0.5022344825 -0.0004167247  0.5658198405 -0.5725226890 -1.1102250073\n[11] -0.0486871234 -0.6956562176  0.8289174803  0.2066528551 -0.2356745091\n[16] -0.5563104914 -0.3647543571  0.8623550343 -0.6307715354  0.3136021252\n[21] -0.9314953177  0.8238676185  0.5233707021  0.7069214120  0.4202043256\n[26] -0.2690521547 -1.5103172999 -0.6902124766 -0.1434719524 -1.0135274099\n[31]  1.5732737361  0.0127465055  0.8726470499  0.4220661905 -0.0188157917\n[36]  2.6157489689 -0.6931401748 -0.2663217810 -0.7206364412  1.3677342065\n[41]  0.2640073322  0.6321868074 -1.3306509858  0.0268888182  1.0406363208\n[46]  1.3120237985 -0.0300020767 -0.2500257125  0.0234144857  1.6598706557\n\n\nWe use set.seed() throughout the labs whenever we perform calculations involving random quantities. In general this should allow the user to reproduce our results. However, as new versions of R become available, small discrepancies may arise between this book and the output from R.\nThe mean() and var() functions can be used to compute the mean and variance of a vector of numbers. Applying sqrt() to the output of var() will give the standard deviation. Or we can simply use the sd() function.\n\nset.seed(3)\ny &lt;- rnorm(100)\nmean(y)\n\n[1] 0.01103557\n\nvar(y)\n\n[1] 0.7328675\n\nsqrt(var(y))\n\n[1] 0.8560768\n\nsd(y)\n\n[1] 0.8560768\n\n\n\n\n\nThe plot() function is the primary way to plot data in R. For instance, plot(x, y) produces a scatterplot of the numbers in x versus the numbers in y. There are many additional options that can be passed in to the plot() function. For example, passing in the argument xlab will result in a label on the \\(x\\)-axis. To find out more information about the plot() function, type ?plot.\n\nx &lt;- rnorm(100)\ny &lt;- rnorm(100)\nplot(x, y)\n\n\n\n\n\n\n\nplot(x, y, xlab = \"this is the x-axis\",\n    ylab = \"this is the y-axis\",\n    main = \"Plot of X vs Y\")\n\n\n\n\n\n\n\n\nWe will often want to save the output of an R plot. The command that we use to do this will depend on the file type that we would like to create. For instance, to create a pdf, we use the pdf() function, and to create a jpeg, we use the jpeg() function.\n\npdf(\"Figure.pdf\")\nplot(x, y, col = \"green\")\ndev.off()\n\npng \n  2 \n\n\nThe function dev.off() indicates to R that we are done creating the plot. Alternatively, we can simply copy the plot window and paste it into an appropriate file type, such as a Word document.\nThe function seq() can be used to create a sequence of numbers. For instance, seq(a, b) makes a vector of integers between a and b. There are many other options: for instance, seq(0, 1, length = 10) makes a sequence of 10 numbers that are equally spaced between 0 and 1. Typing 3:11 is a shorthand for seq(3, 11) for integer arguments.\n\nx &lt;- seq(1, 10)\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nx &lt;- 1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nx &lt;- seq(-pi, pi, length = 50)\n\nWe will now create some more sophisticated plots. The contour() function produces a contour plot in order to represent three-dimensional data; it is like a topographical map. It takes three arguments:\n\nA vector of the x values (the first dimension),\nA vector of the y values (the second dimension), and\nA matrix whose elements correspond to the z value (the third dimension) for each pair of (x, y) coordinates.\n\nAs with the plot() function, there are many other inputs that can be used to fine-tune the output of the contour() function. To learn more about these, take a look at the help file by typing ?contour.\n\ny &lt;- x\nf &lt;- outer(x, y, function(x, y) cos(y) / (1 + x^2))\ncontour(x, y, f)\ncontour(x, y, f, nlevels = 45, add = T)\n\n\n\n\n\n\n\nfa &lt;- (f - t(f)) / 2\ncontour(x, y, fa, nlevels = 15)\n\n\n\n\n\n\n\n\nThe image() function works the same way as contour(), except that it produces a color-coded plot whose colors depend on the z value. This is known as a heatmap, and is sometimes used to plot temperature in weather forecasts. Alternatively, persp() can be used to produce a three-dimensional plot. The arguments theta and phi control the angles at which the plot is viewed.\n\nimage(x, y, fa)\n\n\n\n\n\n\n\npersp(x, y, fa)\n\n\n\n\n\n\n\npersp(x, y, fa, theta = 30)\n\n\n\n\n\n\n\npersp(x, y, fa, theta = 30, phi = 20)\n\n\n\n\n\n\n\npersp(x, y, fa, theta = 30, phi = 70)\n\n\n\n\n\n\n\npersp(x, y, fa, theta = 30, phi = 40)\n\n\n\n\n\n\n\n\n\n\n\nWe often wish to examine part of a set of data. Suppose that our data is stored in the matrix A.\n\nA &lt;- matrix(1:16, 4, 4)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n\n\nThen, typing\n\nA[2, 3]\n\n[1] 10\n\n\nwill select the element corresponding to the second row and the third column. The first number after the open-bracket symbol [ always refers to the row, and the second number always refers to the column. We can also select multiple rows and columns at a time, by providing vectors as the indices.\n\nA[c(1, 3), c(2, 4)]\n\n     [,1] [,2]\n[1,]    5   13\n[2,]    7   15\n\nA[1:3, 2:4]\n\n     [,1] [,2] [,3]\n[1,]    5    9   13\n[2,]    6   10   14\n[3,]    7   11   15\n\nA[1:2, ]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n\nA[, 1:2]\n\n     [,1] [,2]\n[1,]    1    5\n[2,]    2    6\n[3,]    3    7\n[4,]    4    8\n\n\nThe last two examples include either no index for the columns or no index for the rows. These indicate that R should include all columns or all rows, respectively. R treats a single row or column of a matrix as a vector.\n\nA[1, ]\n\n[1]  1  5  9 13\n\n\nThe use of a negative sign - in the index tells R to keep all rows or columns except those indicated in the index.\n\nA[-c(1, 3), ]\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    6   10   14\n[2,]    4    8   12   16\n\nA[-c(1, 3), -c(1, 3, 4)]\n\n[1] 6 8\n\n\nThe dim() function outputs the number of rows followed by the number of columns of a given matrix.\n\ndim(A)\n\n[1] 4 4\n\n\n\n\n\nFor most analyses, the first step involves importing a data set into R. The read.table() function is one of the primary ways to do this. The help file contains details about how to use this function. We can use the function write.table() to export data.\nBefore attempting to load a data set, we must make sure that R knows to search for the data in the proper directory. For example, on a Windows system one could select the directory using the Change dir ... option under the File menu. However, the details of how to do this depend on the operating system (e.g. Windows, Mac, Unix) that is being used, and so we do not give further details here.\nWe begin by loading in the Auto data set. This data is part of the ISLR2 library, discussed in Chapter 3. To illustrate the read.table() function, we load it now from a text file, Auto.data, which you can find on the textbook website. The following command will load the Auto.data file into R and store it as an object called Auto, in a format referred to as a data frame. Once the data has been loaded, the View() function can be used to view it in a spreadsheet-like window. (This function can sometimes be a bit finicky. If you have trouble using it, then try the head() function instead.) The head() function can also be used to view the first few rows of the data.\n\nAuto &lt;- read.table(\"Auto.data\")\n\nWarning in file(file, \"rt\"): cannot open file 'Auto.data': No such file or\ndirectory\n\n\nError in file(file, \"rt\"): cannot open the connection\n\nView(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\nhead(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\n\nNote that Auto.data is simply a text file, which you could alternatively open on your computer using a standard text editor. It is often a good idea to view a data set using a text editor or other software such as Excel before loading it into R.\nThis particular data set has not been loaded correctly, because R has assumed that the variable names are part of the data and so has included them in the first row. The data set also includes a number of missing observations, indicated by a question mark ?. Missing values are a common occurrence in real data sets. Using the option header = T (or header = TRUE) in the read.table() function tells R that the first line of the file contains the variable names, and using the option na.strings tells R that any time it sees a particular character or set of characters (such as a question mark), it should be treated as a missing element of the data matrix.\n\nAuto &lt;- read.table(\"Auto.data\", header = T, na.strings = \"?\", stringsAsFactors = T)\n\nWarning in file(file, \"rt\"): cannot open file 'Auto.data': No such file or\ndirectory\n\n\nError in file(file, \"rt\"): cannot open the connection\n\nView(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\n\nThe stringsAsFactors = T argument tells R that any variable containing character strings should be interpreted as a qualitative variable, and that each distinct character string represents a distinct level for that qualitative variable. An easy way to load data from Excel into R is to save it as a csv (comma-separated values) file, and then use the read.csv() function.\n\nAuto &lt;- read.csv(\"Auto.csv\", na.strings = \"?\", stringsAsFactors = T)\n\nWarning in file(file, \"rt\"): cannot open file 'Auto.csv': No such file or\ndirectory\n\n\nError in file(file, \"rt\"): cannot open the connection\n\nView(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\ndim(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\nAuto[1:4, ]\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\n\nThe dim() function tells us that the data has \\(397\\) observations, or rows, and nine variables, or columns. There are various ways to deal with the missing data. In this case, only five of the rows contain missing observations, and so we choose to use the na.omit() function to simply remove these rows.\n\nAuto &lt;- na.omit(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\ndim(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\n\nOnce the data are loaded correctly, we can use names() to check the variable names.\n\nnames(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\n\n\n\n\nWe can use the plot() function to produce scatterplots of the quantitative variables. However, simply typing the variable names will produce an error message, because R does not know to look in the Auto data set for those variables.\n\nplot(cylinders, mpg)\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\n\nTo refer to a variable, we must type the data set and the variable name joined with a $ symbol. Alternatively, we can use the attach() function in order to tell R to make the variables in this data frame available by name.\n\nplot(Auto$cylinders, Auto$mpg)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\nattach(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\nplot(cylinders, mpg)\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\n\nThe cylinders variable is stored as a numeric vector, so R has treated it as quantitative. However, since there are only a small number of possible values for cylinders, one may prefer to treat it as a qualitative variable. The as.factor() function converts quantitative variables into qualitative variables.\n\ncylinders &lt;- as.factor(cylinders)\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\n\nIf the variable plotted on the \\(x\\)-axis is qualitative, then boxplots will automatically be produced by the plot() function. As usual, a number of options can be specified in order to customize the plots.\n\nplot(cylinders, mpg)\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\nplot(cylinders, mpg, col = \"red\")\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\nplot(cylinders, mpg, col = \"red\", varwidth = T)\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\nplot(cylinders, mpg, col = \"red\", varwidth = T,\n    horizontal = T)\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\nplot(cylinders, mpg, col = \"red\", varwidth = T,\n    xlab = \"cylinders\", ylab = \"MPG\")\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\n\nThe hist() function can be used to plot a histogram. Note that col = 2 has the same effect as col = \"red\".\n\nhist(mpg)\n\nError in eval(expr, envir, enclos): object 'mpg' not found\n\nhist(mpg, col = 2)\n\nError in eval(expr, envir, enclos): object 'mpg' not found\n\nhist(mpg, col = 2, breaks = 15)\n\nError in eval(expr, envir, enclos): object 'mpg' not found\n\n\nThe pairs() function creates a scatterplot matrix, i.e. a scatterplot for every pair of variables. We can also produce scatterplots for just a subset of the variables.\n\npairs(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\npairs(\n    ~ mpg + displacement + horsepower + weight + acceleration,\n    data = Auto\n  )\n\nError in eval(m$data, parent.frame()): object 'Auto' not found\n\n\nIn conjunction with the plot() function, identify() provides a useful interactive method for identifying the value of a particular variable for points on a plot. We pass in three arguments to identify(): the \\(x\\)-axis variable, the \\(y\\)-axis variable, and the variable whose values we would like to see printed for each point. Then clicking one or more points in the plot and hitting Escape will cause R to print the values of the variable of interest. The numbers printed under the identify() function correspond to the rows for the selected points.\n\nplot(horsepower, mpg)\n\nError in eval(expr, envir, enclos): object 'horsepower' not found\n\nidentify(horsepower, mpg, name)\n\nError in eval(expr, envir, enclos): object 'horsepower' not found\n\n\nThe summary() function produces a numerical summary of each variable in a particular data set.\n\nsummary(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\n\nFor qualitative variables such as name, R will list the number of observations that fall in each category. We can also produce a summary of just a single variable.\n\nsummary(mpg)\n\nError in eval(expr, envir, enclos): object 'mpg' not found\n\n\nOnce we have finished using R, we type q() in order to shut it down, or quit. When exiting R, we have the option to save the current workspace so that all objects (such as data sets) that we have created in this R session will be available next time. Before exiting R, we may want to save a record of all of the commands that we typed in the most recent session; this can be accomplished using the savehistory() function. Next time we enter R, we can load that history using the loadhistory() function, if we wish."
  },
  {
    "objectID": "chapter2.html#basic-commands",
    "href": "chapter2.html#basic-commands",
    "title": "chapter2",
    "section": "",
    "text": "R uses functions to perform operations. To run a function called funcname, we type funcname(input1, input2), where the inputs (or arguments) input1 and input2 tell R how to run the function. A function can have any number of inputs. For example, to create a vector of numbers, we use the function c() (for concatenate). Any numbers inside the parentheses are joined together. The following command instructs R to join together the numbers 1, 3, 2, and 5, and to save them as a vector named x. When we type x, it gives us back the vector.\n\nx &lt;- c(1, 3, 2, 5)\nx\n\n[1] 1 3 2 5\n\n\nNote that the &gt; is not part of the command; rather, it is printed by R to indicate that it is ready for another command to be entered. We can also save things using = rather than &lt;-:\n\nx = c(1, 6, 2)\nx\n\n[1] 1 6 2\n\ny = c(1, 4, 3)\n\nHitting the up arrow multiple times will display the previous commands, which can then be edited. This is useful since one often wishes to repeat a similar command. In addition, typing ?funcname will always cause R to open a new help file window with additional information about the function funcname().\nWe can tell R to add two sets of numbers together. It will then add the first number from x to the first number from y, and so on. However, x and y should be the same length. We can check their length using the length() function.\n\nlength(x)\n\n[1] 3\n\nlength(y)\n\n[1] 3\n\nx + y\n\n[1]  2 10  5\n\n\nThe ls() function allows us to look at a list of all of the objects, such as data and functions, that we have saved so far. The rm() function can be used to delete any that we don’t want.\n\nls()\n\n[1] \"x\" \"y\"\n\nrm(x, y)\nls()\n\ncharacter(0)\n\n\nIt’s also possible to remove all objects at once:\n\nrm(list = ls())\n\nThe matrix() function can be used to create a matrix of numbers. Before we use the matrix() function, we can learn more about it:\n\n?matrix\n\nstarting httpd help server ... done\n\n\nThe help file reveals that the matrix() function takes a number of inputs, but for now we focus on the first three: the data (the entries in the matrix), the number of rows, and the number of columns. First, we create a simple matrix.\n\nx &lt;- matrix(data = c(1, 2, 3, 4), nrow = 2, ncol = 2)\nx\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\nNote that we could just as well omit typing data=, nrow=, and ncol= in the matrix() command above: that is, we could just type\n\nx &lt;- matrix(c(1, 2, 3, 4), 2, 2)\n\nand this would have the same effect. However, it can sometimes be useful to specify the names of the arguments passed in, since otherwise R will assume that the function arguments are passed into the function in the same order that is given in the function’s help file. As this example illustrates, by default R creates matrices by successively filling in columns. Alternatively, the byrow = TRUE option can be used to populate the matrix in order of the rows.\n\nmatrix(c(1, 2, 3, 4), 2, 2, byrow = TRUE)\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n\n\nNotice that in the above command we did not assign the matrix to a value such as x. In this case the matrix is printed to the screen but is not saved for future calculations. The sqrt() function returns the square root of each element of a vector or matrix. The command x^2 raises each element of x to the power 2; any powers are possible, including fractional or negative powers.\n\nsqrt(x)\n\n         [,1]     [,2]\n[1,] 1.000000 1.732051\n[2,] 1.414214 2.000000\n\nx^2\n\n     [,1] [,2]\n[1,]    1    9\n[2,]    4   16\n\n\nThe rnorm() function generates a vector of random normal variables, with first argument n the sample size. Each time we call this function, we will get a different answer. Here we create two correlated sets of numbers, x and y, and use the cor() function to compute the correlation between them.\n\nx &lt;- rnorm(50)\ny &lt;- x + rnorm(50, mean = 50, sd = .1)\ncor(x, y)\n\n[1] 0.994796\n\n\nBy default, rnorm() creates standard normal random variables with a mean of \\(0\\) and a standard deviation of \\(1\\). However, the mean and standard deviation can be altered using the mean and sd arguments, as illustrated above. Sometimes we want our code to reproduce the exact same set of random numbers; we can use the set.seed() function to do this. The set.seed() function takes an (arbitrary) integer argument.\n\nset.seed(1303)\nrnorm(50)\n\n [1] -1.1439763145  1.3421293656  2.1853904757  0.5363925179  0.0631929665\n [6]  0.5022344825 -0.0004167247  0.5658198405 -0.5725226890 -1.1102250073\n[11] -0.0486871234 -0.6956562176  0.8289174803  0.2066528551 -0.2356745091\n[16] -0.5563104914 -0.3647543571  0.8623550343 -0.6307715354  0.3136021252\n[21] -0.9314953177  0.8238676185  0.5233707021  0.7069214120  0.4202043256\n[26] -0.2690521547 -1.5103172999 -0.6902124766 -0.1434719524 -1.0135274099\n[31]  1.5732737361  0.0127465055  0.8726470499  0.4220661905 -0.0188157917\n[36]  2.6157489689 -0.6931401748 -0.2663217810 -0.7206364412  1.3677342065\n[41]  0.2640073322  0.6321868074 -1.3306509858  0.0268888182  1.0406363208\n[46]  1.3120237985 -0.0300020767 -0.2500257125  0.0234144857  1.6598706557\n\n\nWe use set.seed() throughout the labs whenever we perform calculations involving random quantities. In general this should allow the user to reproduce our results. However, as new versions of R become available, small discrepancies may arise between this book and the output from R.\nThe mean() and var() functions can be used to compute the mean and variance of a vector of numbers. Applying sqrt() to the output of var() will give the standard deviation. Or we can simply use the sd() function.\n\nset.seed(3)\ny &lt;- rnorm(100)\nmean(y)\n\n[1] 0.01103557\n\nvar(y)\n\n[1] 0.7328675\n\nsqrt(var(y))\n\n[1] 0.8560768\n\nsd(y)\n\n[1] 0.8560768"
  },
  {
    "objectID": "chapter2.html#graphics",
    "href": "chapter2.html#graphics",
    "title": "chapter2",
    "section": "",
    "text": "The plot() function is the primary way to plot data in R. For instance, plot(x, y) produces a scatterplot of the numbers in x versus the numbers in y. There are many additional options that can be passed in to the plot() function. For example, passing in the argument xlab will result in a label on the \\(x\\)-axis. To find out more information about the plot() function, type ?plot.\n\nx &lt;- rnorm(100)\ny &lt;- rnorm(100)\nplot(x, y)\n\n\n\n\n\n\n\nplot(x, y, xlab = \"this is the x-axis\",\n    ylab = \"this is the y-axis\",\n    main = \"Plot of X vs Y\")\n\n\n\n\n\n\n\n\nWe will often want to save the output of an R plot. The command that we use to do this will depend on the file type that we would like to create. For instance, to create a pdf, we use the pdf() function, and to create a jpeg, we use the jpeg() function.\n\npdf(\"Figure.pdf\")\nplot(x, y, col = \"green\")\ndev.off()\n\npng \n  2 \n\n\nThe function dev.off() indicates to R that we are done creating the plot. Alternatively, we can simply copy the plot window and paste it into an appropriate file type, such as a Word document.\nThe function seq() can be used to create a sequence of numbers. For instance, seq(a, b) makes a vector of integers between a and b. There are many other options: for instance, seq(0, 1, length = 10) makes a sequence of 10 numbers that are equally spaced between 0 and 1. Typing 3:11 is a shorthand for seq(3, 11) for integer arguments.\n\nx &lt;- seq(1, 10)\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nx &lt;- 1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nx &lt;- seq(-pi, pi, length = 50)\n\nWe will now create some more sophisticated plots. The contour() function produces a contour plot in order to represent three-dimensional data; it is like a topographical map. It takes three arguments:\n\nA vector of the x values (the first dimension),\nA vector of the y values (the second dimension), and\nA matrix whose elements correspond to the z value (the third dimension) for each pair of (x, y) coordinates.\n\nAs with the plot() function, there are many other inputs that can be used to fine-tune the output of the contour() function. To learn more about these, take a look at the help file by typing ?contour.\n\ny &lt;- x\nf &lt;- outer(x, y, function(x, y) cos(y) / (1 + x^2))\ncontour(x, y, f)\ncontour(x, y, f, nlevels = 45, add = T)\n\n\n\n\n\n\n\nfa &lt;- (f - t(f)) / 2\ncontour(x, y, fa, nlevels = 15)\n\n\n\n\n\n\n\n\nThe image() function works the same way as contour(), except that it produces a color-coded plot whose colors depend on the z value. This is known as a heatmap, and is sometimes used to plot temperature in weather forecasts. Alternatively, persp() can be used to produce a three-dimensional plot. The arguments theta and phi control the angles at which the plot is viewed.\n\nimage(x, y, fa)\n\n\n\n\n\n\n\npersp(x, y, fa)\n\n\n\n\n\n\n\npersp(x, y, fa, theta = 30)\n\n\n\n\n\n\n\npersp(x, y, fa, theta = 30, phi = 20)\n\n\n\n\n\n\n\npersp(x, y, fa, theta = 30, phi = 70)\n\n\n\n\n\n\n\npersp(x, y, fa, theta = 30, phi = 40)"
  },
  {
    "objectID": "chapter2.html#indexing-data",
    "href": "chapter2.html#indexing-data",
    "title": "chapter2",
    "section": "",
    "text": "We often wish to examine part of a set of data. Suppose that our data is stored in the matrix A.\n\nA &lt;- matrix(1:16, 4, 4)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n[3,]    3    7   11   15\n[4,]    4    8   12   16\n\n\nThen, typing\n\nA[2, 3]\n\n[1] 10\n\n\nwill select the element corresponding to the second row and the third column. The first number after the open-bracket symbol [ always refers to the row, and the second number always refers to the column. We can also select multiple rows and columns at a time, by providing vectors as the indices.\n\nA[c(1, 3), c(2, 4)]\n\n     [,1] [,2]\n[1,]    5   13\n[2,]    7   15\n\nA[1:3, 2:4]\n\n     [,1] [,2] [,3]\n[1,]    5    9   13\n[2,]    6   10   14\n[3,]    7   11   15\n\nA[1:2, ]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    5    9   13\n[2,]    2    6   10   14\n\nA[, 1:2]\n\n     [,1] [,2]\n[1,]    1    5\n[2,]    2    6\n[3,]    3    7\n[4,]    4    8\n\n\nThe last two examples include either no index for the columns or no index for the rows. These indicate that R should include all columns or all rows, respectively. R treats a single row or column of a matrix as a vector.\n\nA[1, ]\n\n[1]  1  5  9 13\n\n\nThe use of a negative sign - in the index tells R to keep all rows or columns except those indicated in the index.\n\nA[-c(1, 3), ]\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    6   10   14\n[2,]    4    8   12   16\n\nA[-c(1, 3), -c(1, 3, 4)]\n\n[1] 6 8\n\n\nThe dim() function outputs the number of rows followed by the number of columns of a given matrix.\n\ndim(A)\n\n[1] 4 4"
  },
  {
    "objectID": "chapter2.html#loading-data",
    "href": "chapter2.html#loading-data",
    "title": "chapter2",
    "section": "",
    "text": "For most analyses, the first step involves importing a data set into R. The read.table() function is one of the primary ways to do this. The help file contains details about how to use this function. We can use the function write.table() to export data.\nBefore attempting to load a data set, we must make sure that R knows to search for the data in the proper directory. For example, on a Windows system one could select the directory using the Change dir ... option under the File menu. However, the details of how to do this depend on the operating system (e.g. Windows, Mac, Unix) that is being used, and so we do not give further details here.\nWe begin by loading in the Auto data set. This data is part of the ISLR2 library, discussed in Chapter 3. To illustrate the read.table() function, we load it now from a text file, Auto.data, which you can find on the textbook website. The following command will load the Auto.data file into R and store it as an object called Auto, in a format referred to as a data frame. Once the data has been loaded, the View() function can be used to view it in a spreadsheet-like window. (This function can sometimes be a bit finicky. If you have trouble using it, then try the head() function instead.) The head() function can also be used to view the first few rows of the data.\n\nAuto &lt;- read.table(\"Auto.data\")\n\nWarning in file(file, \"rt\"): cannot open file 'Auto.data': No such file or\ndirectory\n\n\nError in file(file, \"rt\"): cannot open the connection\n\nView(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\nhead(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\n\nNote that Auto.data is simply a text file, which you could alternatively open on your computer using a standard text editor. It is often a good idea to view a data set using a text editor or other software such as Excel before loading it into R.\nThis particular data set has not been loaded correctly, because R has assumed that the variable names are part of the data and so has included them in the first row. The data set also includes a number of missing observations, indicated by a question mark ?. Missing values are a common occurrence in real data sets. Using the option header = T (or header = TRUE) in the read.table() function tells R that the first line of the file contains the variable names, and using the option na.strings tells R that any time it sees a particular character or set of characters (such as a question mark), it should be treated as a missing element of the data matrix.\n\nAuto &lt;- read.table(\"Auto.data\", header = T, na.strings = \"?\", stringsAsFactors = T)\n\nWarning in file(file, \"rt\"): cannot open file 'Auto.data': No such file or\ndirectory\n\n\nError in file(file, \"rt\"): cannot open the connection\n\nView(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\n\nThe stringsAsFactors = T argument tells R that any variable containing character strings should be interpreted as a qualitative variable, and that each distinct character string represents a distinct level for that qualitative variable. An easy way to load data from Excel into R is to save it as a csv (comma-separated values) file, and then use the read.csv() function.\n\nAuto &lt;- read.csv(\"Auto.csv\", na.strings = \"?\", stringsAsFactors = T)\n\nWarning in file(file, \"rt\"): cannot open file 'Auto.csv': No such file or\ndirectory\n\n\nError in file(file, \"rt\"): cannot open the connection\n\nView(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\ndim(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\nAuto[1:4, ]\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\n\nThe dim() function tells us that the data has \\(397\\) observations, or rows, and nine variables, or columns. There are various ways to deal with the missing data. In this case, only five of the rows contain missing observations, and so we choose to use the na.omit() function to simply remove these rows.\n\nAuto &lt;- na.omit(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\ndim(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\n\nOnce the data are loaded correctly, we can use names() to check the variable names.\n\nnames(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found"
  },
  {
    "objectID": "chapter2.html#additional-graphical-and-numerical-summaries",
    "href": "chapter2.html#additional-graphical-and-numerical-summaries",
    "title": "chapter2",
    "section": "",
    "text": "We can use the plot() function to produce scatterplots of the quantitative variables. However, simply typing the variable names will produce an error message, because R does not know to look in the Auto data set for those variables.\n\nplot(cylinders, mpg)\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\n\nTo refer to a variable, we must type the data set and the variable name joined with a $ symbol. Alternatively, we can use the attach() function in order to tell R to make the variables in this data frame available by name.\n\nplot(Auto$cylinders, Auto$mpg)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\nattach(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\nplot(cylinders, mpg)\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\n\nThe cylinders variable is stored as a numeric vector, so R has treated it as quantitative. However, since there are only a small number of possible values for cylinders, one may prefer to treat it as a qualitative variable. The as.factor() function converts quantitative variables into qualitative variables.\n\ncylinders &lt;- as.factor(cylinders)\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\n\nIf the variable plotted on the \\(x\\)-axis is qualitative, then boxplots will automatically be produced by the plot() function. As usual, a number of options can be specified in order to customize the plots.\n\nplot(cylinders, mpg)\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\nplot(cylinders, mpg, col = \"red\")\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\nplot(cylinders, mpg, col = \"red\", varwidth = T)\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\nplot(cylinders, mpg, col = \"red\", varwidth = T,\n    horizontal = T)\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\nplot(cylinders, mpg, col = \"red\", varwidth = T,\n    xlab = \"cylinders\", ylab = \"MPG\")\n\nError in eval(expr, envir, enclos): object 'cylinders' not found\n\n\nThe hist() function can be used to plot a histogram. Note that col = 2 has the same effect as col = \"red\".\n\nhist(mpg)\n\nError in eval(expr, envir, enclos): object 'mpg' not found\n\nhist(mpg, col = 2)\n\nError in eval(expr, envir, enclos): object 'mpg' not found\n\nhist(mpg, col = 2, breaks = 15)\n\nError in eval(expr, envir, enclos): object 'mpg' not found\n\n\nThe pairs() function creates a scatterplot matrix, i.e. a scatterplot for every pair of variables. We can also produce scatterplots for just a subset of the variables.\n\npairs(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\npairs(\n    ~ mpg + displacement + horsepower + weight + acceleration,\n    data = Auto\n  )\n\nError in eval(m$data, parent.frame()): object 'Auto' not found\n\n\nIn conjunction with the plot() function, identify() provides a useful interactive method for identifying the value of a particular variable for points on a plot. We pass in three arguments to identify(): the \\(x\\)-axis variable, the \\(y\\)-axis variable, and the variable whose values we would like to see printed for each point. Then clicking one or more points in the plot and hitting Escape will cause R to print the values of the variable of interest. The numbers printed under the identify() function correspond to the rows for the selected points.\n\nplot(horsepower, mpg)\n\nError in eval(expr, envir, enclos): object 'horsepower' not found\n\nidentify(horsepower, mpg, name)\n\nError in eval(expr, envir, enclos): object 'horsepower' not found\n\n\nThe summary() function produces a numerical summary of each variable in a particular data set.\n\nsummary(Auto)\n\nError in eval(expr, envir, enclos): object 'Auto' not found\n\n\nFor qualitative variables such as name, R will list the number of observations that fall in each category. We can also produce a summary of just a single variable.\n\nsummary(mpg)\n\nError in eval(expr, envir, enclos): object 'mpg' not found\n\n\nOnce we have finished using R, we type q() in order to shut it down, or quit. When exiting R, we have the option to save the current workspace so that all objects (such as data sets) that we have created in this R session will be available next time. Before exiting R, we may want to save a record of all of the commands that we typed in the most recent session; this can be accomplished using the savehistory() function. Next time we enter R, we can load that history using the loadhistory() function, if we wish."
  },
  {
    "objectID": "ggplot2.html",
    "href": "ggplot2.html",
    "title": "ggplot2",
    "section": "",
    "text": "install.packages(“ggplot2”)\n\n# Library\nlibrary(ggplot2)\n\nWarning: package 'ggplot2' was built under R version 4.4.1\n\n# create a dataset\ndata &lt;- data.frame(\n  name=c( rep(\"A\",500), rep(\"B\",500), rep(\"B\",500), rep(\"C\",20), rep('D', 100)  ),\n  value=c( rnorm(500, 10, 5), rnorm(500, 13, 1), rnorm(500, 18, 1), rnorm(20, 25, 4), rnorm(100, 12, 1) )\n)\n\n# Most basic violin chart\np &lt;- ggplot(data, aes(x=name, y=value, fill=name)) + # fill=name allow to automatically dedicate a color for each group\n  geom_violin()\n\np\n\n\n\n\n\n\n\n# The mtcars dataset:\ndata &lt;- as.matrix(mtcars)\n\n# Default Heatmap\nheatmap(data)"
  },
  {
    "objectID": "chapter3.html",
    "href": "chapter3.html",
    "title": "chapter3",
    "section": "",
    "text": "The library() function is used to load libraries, or groups of functions and data sets that are not included in the base R distribution. Basic functions that perform least squares linear regression and other simple analyses come standard with the base distribution, but more exotic functions require additional libraries. Here we load the MASS package, which is a very large collection of data sets and functions. We also load the ISLR2 package, which includes the data sets associated with this book.\n\nlibrary(MASS)\nlibrary(ISLR2)\n\nWarning: package 'ISLR2' was built under R version 4.4.1\n\n\n\nAttaching package: 'ISLR2'\n\n\nThe following object is masked from 'package:MASS':\n\n    Boston\n\n\nIf you receive an error message when loading any of these libraries, it likely indicates that the corresponding library has not yet been installed on your system. Some libraries, such as MASS, come with R and do not need to be separately installed on your computer. However, other packages, such as ISLR2, must be downloaded the first time they are used. This can be done directly from within R. For example, on a Windows system, select the Install package option under the Packages tab. After you select any mirror site, a list of available packages will appear. Simply select the package you wish to install and R will automatically download the package. Alternatively, this can be done at the R command line via install.packages(\"ISLR2\"). This installation only needs to be done the first time you use a package. However, the library() function must be called within each R session.\n\n\n\nThe ISLR2 library contains the Boston data set, which records medv (median house value) for \\(506\\) census tracts in Boston. We will seek to predict medv using \\(12\\) predictors such as rmvar (average number of rooms per house), age (proportion of owner-occupied units built prior to 1940) and lstat (percent of households with low socioeconomic status).\n\nhead(Boston)\n\n     crim zn indus chas   nox    rm  age    dis rad tax ptratio lstat medv\n1 0.00632 18  2.31    0 0.538 6.575 65.2 4.0900   1 296    15.3  4.98 24.0\n2 0.02731  0  7.07    0 0.469 6.421 78.9 4.9671   2 242    17.8  9.14 21.6\n3 0.02729  0  7.07    0 0.469 7.185 61.1 4.9671   2 242    17.8  4.03 34.7\n4 0.03237  0  2.18    0 0.458 6.998 45.8 6.0622   3 222    18.7  2.94 33.4\n5 0.06905  0  2.18    0 0.458 7.147 54.2 6.0622   3 222    18.7  5.33 36.2\n6 0.02985  0  2.18    0 0.458 6.430 58.7 6.0622   3 222    18.7  5.21 28.7\n\n\nTo find out more about the data set, we can type ?Boston.\nWe will start by using the lm() function to fit a simple linear regression model, with medv as the response and lstat as the predictor. The basic syntax is lm(y ~ x, data), where y is the response, x is the predictor, and data is the data set in which these two variables are kept.\n\nlm.fit &lt;- lm(medv ~ lstat)\n\nError in eval(predvars, data, env): object 'medv' not found\n\n\nThe command causes an error because R does not know where to find the variables medv and lstat. The next line tells R that the variables are in Boston. If we attach Boston, the first line works fine because R now recognizes the variables.\n\nlm.fit &lt;- lm(medv ~ lstat, data = Boston)\nattach(Boston)\nlm.fit &lt;- lm(medv ~ lstat)\n\nIf we type lm.fit, some basic information about the model is output. For more detailed information, we use summary(lm.fit). This gives us \\(p\\)-values and standard errors for the coefficients, as well as the \\(R^2\\) statistic and \\(F\\)-statistic for the model.\n\nlm.fit\n\n\nCall:\nlm(formula = medv ~ lstat)\n\nCoefficients:\n(Intercept)        lstat  \n      34.55        -0.95  \n\nsummary(lm.fit)\n\n\nCall:\nlm(formula = medv ~ lstat)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-15.168  -3.990  -1.318   2.034  24.500 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 34.55384    0.56263   61.41   &lt;2e-16 ***\nlstat       -0.95005    0.03873  -24.53   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.216 on 504 degrees of freedom\nMultiple R-squared:  0.5441,    Adjusted R-squared:  0.5432 \nF-statistic: 601.6 on 1 and 504 DF,  p-value: &lt; 2.2e-16\n\n\nWe can use the names() function in order to find out what other pieces of information are stored in lm.fit. Although we can extract these quantities by name—e.g. lm.fit$coefficients—it is safer to use the extractor functions like coef() to access them.\n\nnames(lm.fit)\n\n [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"        \n\ncoef(lm.fit)\n\n(Intercept)       lstat \n 34.5538409  -0.9500494 \n\n\nIn order to obtain a confidence interval for the coefficient estimates, we can use the confint() command.\n\nconfint(lm.fit)\n\n                2.5 %     97.5 %\n(Intercept) 33.448457 35.6592247\nlstat       -1.026148 -0.8739505\n\n\nThe predict() function can be used to produce confidence intervals and prediction intervals for the prediction of medv for a given value of lstat.\n\npredict(lm.fit, data.frame(lstat = (c(5, 10, 15))),\n    interval = \"confidence\")\n\n       fit      lwr      upr\n1 29.80359 29.00741 30.59978\n2 25.05335 24.47413 25.63256\n3 20.30310 19.73159 20.87461\n\npredict(lm.fit, data.frame(lstat = (c(5, 10, 15))),\n    interval = \"prediction\")\n\n       fit       lwr      upr\n1 29.80359 17.565675 42.04151\n2 25.05335 12.827626 37.27907\n3 20.30310  8.077742 32.52846\n\n\nFor instance, the 95 % confidence interval associated with a lstat value of 10 is \\((24.47, 25.63)\\), and the 95 % prediction interval is \\((12.828, 37.28)\\). As expected, the confidence and prediction intervals are centered around the same point (a predicted value of \\(25.05\\) for medv when lstat equals 10), but the latter are substantially wider.\nWe will now plot medv and lstat along with the least squares regression line using the plot() and abline() functions.\n\nplot(lstat, medv)\nabline(lm.fit)\n\n\n\n\n\n\n\n\nThere is some evidence for non-linearity in the relationship between lstat and medv. We will explore this issue later in this lab.\nThe abline() function can be used to draw any line, not just the least squares regression line. To draw a line with intercept a and slope b, we type abline(a, b). Below we experiment with some additional settings for plotting lines and points. The lwd = 3 command causes the width of the regression line to be increased by a factor of 3; this works for the plot() and lines() functions also. We can also use the pch option to create different plotting symbols.\n\nplot(lstat, medv)\nabline(lm.fit, lwd = 3)\nabline(lm.fit, lwd = 3, col = \"red\")\n\n\n\n\n\n\n\nplot(lstat, medv, col = \"red\")\n\n\n\n\n\n\n\nplot(lstat, medv, pch = 20)\n\n\n\n\n\n\n\nplot(lstat, medv, pch = \"+\")\n\n\n\n\n\n\n\nplot(1:20, 1:20, pch = 1:20)\n\n\n\n\n\n\n\n\nNext we examine some diagnostic plots, several of which were discussed in Section 3.3.3. Four diagnostic plots are automatically produced by applying the plot() function directly to the output from lm(). In general, this command will produce one plot at a time, and hitting Enter will generate the next plot. However, it is often convenient to view all four plots together. We can achieve this by using the par() and mfrow() functions, which tell R to split the display screen into separate panels so that multiple plots can be viewed simultaneously. For example, par(mfrow = c(2, 2)) divides the plotting region into a \\(2 \\times 2\\) grid of panels.\n\npar(mfrow = c(2, 2))\nplot(lm.fit)\n\n\n\n\n\n\n\n\nAlternatively, we can compute the residuals from a linear regression fit using the residuals() function. The function rstudent() will return the studentized residuals, and we can use this function to plot the residuals against the fitted values.\n\nplot(predict(lm.fit), residuals(lm.fit))\n\n\n\n\n\n\n\nplot(predict(lm.fit), rstudent(lm.fit))\n\n\n\n\n\n\n\n\nOn the basis of the residual plots, there is some evidence of non-linearity. Leverage statistics can be computed for any number of predictors using the hatvalues() function.\n\nplot(hatvalues(lm.fit))\n\n\n\n\n\n\n\nwhich.max(hatvalues(lm.fit))\n\n375 \n375 \n\n\nThe which.max() function identifies the index of the largest element of a vector. In this case, it tells us which observation has the largest leverage statistic.\n\n\n\nIn order to fit a multiple linear regression model using least squares, we again use the lm() function. The syntax lm(y ~ x1 + x2 + x3) is used to fit a model with three predictors, x1, x2, and x3. The summary() function now outputs the regression coefficients for all the predictors.\n\nlm.fit &lt;- lm(medv ~ lstat + age, data = Boston)\nsummary(lm.fit)\n\n\nCall:\nlm(formula = medv ~ lstat + age, data = Boston)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-15.981  -3.978  -1.283   1.968  23.158 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 33.22276    0.73085  45.458  &lt; 2e-16 ***\nlstat       -1.03207    0.04819 -21.416  &lt; 2e-16 ***\nage          0.03454    0.01223   2.826  0.00491 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.173 on 503 degrees of freedom\nMultiple R-squared:  0.5513,    Adjusted R-squared:  0.5495 \nF-statistic:   309 on 2 and 503 DF,  p-value: &lt; 2.2e-16\n\n\nThe Boston data set contains 12 variables, and so it would be cumbersome to have to type all of these in order to perform a regression using all of the predictors. Instead, we can use the following short-hand:\n\nlm.fit &lt;- lm(medv ~ ., data = Boston)\nsummary(lm.fit)\n\n\nCall:\nlm(formula = medv ~ ., data = Boston)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-15.1304  -2.7673  -0.5814   1.9414  26.2526 \n\nCoefficients:\n              Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  41.617270   4.936039   8.431 3.79e-16 ***\ncrim         -0.121389   0.033000  -3.678 0.000261 ***\nzn            0.046963   0.013879   3.384 0.000772 ***\nindus         0.013468   0.062145   0.217 0.828520    \nchas          2.839993   0.870007   3.264 0.001173 ** \nnox         -18.758022   3.851355  -4.870 1.50e-06 ***\nrm            3.658119   0.420246   8.705  &lt; 2e-16 ***\nage           0.003611   0.013329   0.271 0.786595    \ndis          -1.490754   0.201623  -7.394 6.17e-13 ***\nrad           0.289405   0.066908   4.325 1.84e-05 ***\ntax          -0.012682   0.003801  -3.337 0.000912 ***\nptratio      -0.937533   0.132206  -7.091 4.63e-12 ***\nlstat        -0.552019   0.050659 -10.897  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.798 on 493 degrees of freedom\nMultiple R-squared:  0.7343,    Adjusted R-squared:  0.7278 \nF-statistic: 113.5 on 12 and 493 DF,  p-value: &lt; 2.2e-16\n\n\nWe can access the individual components of a summary object by name (type ?summary.lm to see what is available). Hence summary(lm.fit)$r.sq gives us the \\(R^2\\), and summary(lm.fit)$sigma gives us the RSE. The vif() function, part of the car package, can be used to compute variance inflation factors. Most VIF’s are low to moderate for this data. The car package is not part of the base R installation so it must be downloaded the first time you use it via the install.packages() function in R.\n\nlibrary(car)\n\nLoading required package: carData\n\nvif(lm.fit)\n\n    crim       zn    indus     chas      nox       rm      age      dis \n1.767486 2.298459 3.987181 1.071168 4.369093 1.912532 3.088232 3.954037 \n     rad      tax  ptratio    lstat \n7.445301 9.002158 1.797060 2.870777 \n\n\nWhat if we would like to perform a regression using all of the variables but one? For example, in the above regression output, age has a high \\(p\\)-value. So we may wish to run a regression excluding this predictor. The following syntax results in a regression using all predictors except age.\n\nlm.fit1 &lt;- lm(medv ~ . - age, data = Boston)\nsummary(lm.fit1)\n\n\nCall:\nlm(formula = medv ~ . - age, data = Boston)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-15.1851  -2.7330  -0.6116   1.8555  26.3838 \n\nCoefficients:\n              Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  41.525128   4.919684   8.441 3.52e-16 ***\ncrim         -0.121426   0.032969  -3.683 0.000256 ***\nzn            0.046512   0.013766   3.379 0.000785 ***\nindus         0.013451   0.062086   0.217 0.828577    \nchas          2.852773   0.867912   3.287 0.001085 ** \nnox         -18.485070   3.713714  -4.978 8.91e-07 ***\nrm            3.681070   0.411230   8.951  &lt; 2e-16 ***\ndis          -1.506777   0.192570  -7.825 3.12e-14 ***\nrad           0.287940   0.066627   4.322 1.87e-05 ***\ntax          -0.012653   0.003796  -3.333 0.000923 ***\nptratio      -0.934649   0.131653  -7.099 4.39e-12 ***\nlstat        -0.547409   0.047669 -11.483  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.794 on 494 degrees of freedom\nMultiple R-squared:  0.7343,    Adjusted R-squared:  0.7284 \nF-statistic: 124.1 on 11 and 494 DF,  p-value: &lt; 2.2e-16\n\n\nAlternatively, the update() function can be used.\n\nlm.fit1 &lt;- update(lm.fit, ~ . - age)\n\n\n\n\nIt is easy to include interaction terms in a linear model using the lm() function. The syntax lstat:age tells R to include an interaction term between lstat and age. The syntax lstat * age simultaneously includes lstat, age, and the interaction term lstat\\(\\times\\)age as predictors; it is a shorthand for lstat + age + lstat:age. %We can also pass in transformed versions of the predictors.\n\nsummary(lm(medv ~ lstat * age, data = Boston))\n\n\nCall:\nlm(formula = medv ~ lstat * age, data = Boston)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-15.806  -4.045  -1.333   2.085  27.552 \n\nCoefficients:\n              Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 36.0885359  1.4698355  24.553  &lt; 2e-16 ***\nlstat       -1.3921168  0.1674555  -8.313 8.78e-16 ***\nage         -0.0007209  0.0198792  -0.036   0.9711    \nlstat:age    0.0041560  0.0018518   2.244   0.0252 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.149 on 502 degrees of freedom\nMultiple R-squared:  0.5557,    Adjusted R-squared:  0.5531 \nF-statistic: 209.3 on 3 and 502 DF,  p-value: &lt; 2.2e-16\n\n\n\n\n\nThe lm() function can also accommodate non-linear transformations of the predictors. For instance, given a predictor \\(X\\), we can create a predictor \\(X^2\\) using I(X^2). The function I() is needed since the ^ has a special meaning in a formula object; wrapping as we do allows the standard usage in R, which is to raise X to the power 2. We now perform a regression of medv onto lstat and lstat^2.\n\nlm.fit2 &lt;- lm(medv ~ lstat + I(lstat^2))\nsummary(lm.fit2)\n\n\nCall:\nlm(formula = medv ~ lstat + I(lstat^2))\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-15.2834  -3.8313  -0.5295   2.3095  25.4148 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 42.862007   0.872084   49.15   &lt;2e-16 ***\nlstat       -2.332821   0.123803  -18.84   &lt;2e-16 ***\nI(lstat^2)   0.043547   0.003745   11.63   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 5.524 on 503 degrees of freedom\nMultiple R-squared:  0.6407,    Adjusted R-squared:  0.6393 \nF-statistic: 448.5 on 2 and 503 DF,  p-value: &lt; 2.2e-16\n\n\nThe near-zero \\(p\\)-value associated with the quadratic term suggests that it leads to an improved model. We use the anova() function to further quantify the extent to which the quadratic fit is superior to the linear fit.\n\nlm.fit &lt;- lm(medv ~ lstat)\nanova(lm.fit, lm.fit2)\n\nAnalysis of Variance Table\n\nModel 1: medv ~ lstat\nModel 2: medv ~ lstat + I(lstat^2)\n  Res.Df   RSS Df Sum of Sq     F    Pr(&gt;F)    \n1    504 19472                                 \n2    503 15347  1    4125.1 135.2 &lt; 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nHere Model 1 represents the linear submodel containing only one predictor, lstat, while Model 2 corresponds to the larger quadratic model that has two predictors, lstat and lstat^2. The anova() function performs a hypothesis test comparing the two models. The null hypothesis is that the two models fit the data equally well, and the alternative hypothesis is that the full model is superior. Here the \\(F\\)-statistic is \\(135\\) and the associated \\(p\\)-value is virtually zero. This provides very clear evidence that the model containing the predictors lstat and lstat^2 is far superior to the model that only contains the predictor lstat. This is not surprising, since earlier we saw evidence for non-linearity in the relationship between medv and lstat. If we type\n\npar(mfrow = c(2, 2))\nplot(lm.fit2)\n\n\n\n\n\n\n\n\nthen we see that when the lstat^2 term is included in the model, there is little discernible pattern in the residuals.\nIn order to create a cubic fit, we can include a predictor of the form I(X^3). However, this approach can start to get cumbersome for higher-order polynomials. A better approach involves using the poly() function to create the polynomial within lm(). For example, the following command produces a fifth-order polynomial fit:\n\nlm.fit5 &lt;- lm(medv ~ poly(lstat, 5))\nsummary(lm.fit5)\n\n\nCall:\nlm(formula = medv ~ poly(lstat, 5))\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-13.5433  -3.1039  -0.7052   2.0844  27.1153 \n\nCoefficients:\n                 Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)       22.5328     0.2318  97.197  &lt; 2e-16 ***\npoly(lstat, 5)1 -152.4595     5.2148 -29.236  &lt; 2e-16 ***\npoly(lstat, 5)2   64.2272     5.2148  12.316  &lt; 2e-16 ***\npoly(lstat, 5)3  -27.0511     5.2148  -5.187 3.10e-07 ***\npoly(lstat, 5)4   25.4517     5.2148   4.881 1.42e-06 ***\npoly(lstat, 5)5  -19.2524     5.2148  -3.692 0.000247 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 5.215 on 500 degrees of freedom\nMultiple R-squared:  0.6817,    Adjusted R-squared:  0.6785 \nF-statistic: 214.2 on 5 and 500 DF,  p-value: &lt; 2.2e-16\n\n\nThis suggests that including additional polynomial terms, up to fifth order, leads to an improvement in the model fit! However, further investigation of the data reveals that no polynomial terms beyond fifth order have significant \\(p\\)-values in a regression fit.\nBy default, the poly() function orthogonalizes the predictors: this means that the features output by this function are not simply a sequence of powers of the argument. However, a linear model applied to the output of the poly() function will have the same fitted values as a linear model applied to the raw polynomials (although the coefficient estimates, standard errors, and p-values will differ). In order to obtain the raw polynomials from the poly() function, the argument raw = TRUE must be used.\nOf course, we are in no way restricted to using polynomial transformations of the predictors. Here we try a log transformation.\n\nsummary(lm(medv ~ log(rm), data = Boston))\n\n\nCall:\nlm(formula = medv ~ log(rm), data = Boston)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-19.487  -2.875  -0.104   2.837  39.816 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  -76.488      5.028  -15.21   &lt;2e-16 ***\nlog(rm)       54.055      2.739   19.73   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.915 on 504 degrees of freedom\nMultiple R-squared:  0.4358,    Adjusted R-squared:  0.4347 \nF-statistic: 389.3 on 1 and 504 DF,  p-value: &lt; 2.2e-16\n\n\n\n\n\nWe will now examine the Carseats data, which is part of the ISLR2 library. We will attempt to predict Sales (child car seat sales) in \\(400\\) locations based on a number of predictors.\n\nhead(Carseats)\n\n  Sales CompPrice Income Advertising Population Price ShelveLoc Age Education\n1  9.50       138     73          11        276   120       Bad  42        17\n2 11.22       111     48          16        260    83      Good  65        10\n3 10.06       113     35          10        269    80    Medium  59        12\n4  7.40       117    100           4        466    97    Medium  55        14\n5  4.15       141     64           3        340   128       Bad  38        13\n6 10.81       124    113          13        501    72       Bad  78        16\n  Urban  US\n1   Yes Yes\n2   Yes Yes\n3   Yes Yes\n4   Yes Yes\n5   Yes  No\n6    No Yes\n\n\nThe Carseats data includes qualitative predictors such as shelveloc, an indicator of the quality of the shelving location—that is, the space within a store in which the car seat is displayed—at each location. The predictor shelveloc takes on three possible values: Bad, Medium, and Good. Given a qualitative variable such as shelveloc, R generates dummy variables automatically. Below we fit a multiple regression model that includes some interaction terms.\n\nlm.fit &lt;- lm(Sales ~ . + Income:Advertising + Price:Age, \n    data = Carseats)\nsummary(lm.fit)\n\n\nCall:\nlm(formula = Sales ~ . + Income:Advertising + Price:Age, data = Carseats)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.9208 -0.7503  0.0177  0.6754  3.3413 \n\nCoefficients:\n                     Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)         6.5755654  1.0087470   6.519 2.22e-10 ***\nCompPrice           0.0929371  0.0041183  22.567  &lt; 2e-16 ***\nIncome              0.0108940  0.0026044   4.183 3.57e-05 ***\nAdvertising         0.0702462  0.0226091   3.107 0.002030 ** \nPopulation          0.0001592  0.0003679   0.433 0.665330    \nPrice              -0.1008064  0.0074399 -13.549  &lt; 2e-16 ***\nShelveLocGood       4.8486762  0.1528378  31.724  &lt; 2e-16 ***\nShelveLocMedium     1.9532620  0.1257682  15.531  &lt; 2e-16 ***\nAge                -0.0579466  0.0159506  -3.633 0.000318 ***\nEducation          -0.0208525  0.0196131  -1.063 0.288361    \nUrbanYes            0.1401597  0.1124019   1.247 0.213171    \nUSYes              -0.1575571  0.1489234  -1.058 0.290729    \nIncome:Advertising  0.0007510  0.0002784   2.698 0.007290 ** \nPrice:Age           0.0001068  0.0001333   0.801 0.423812    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.011 on 386 degrees of freedom\nMultiple R-squared:  0.8761,    Adjusted R-squared:  0.8719 \nF-statistic:   210 on 13 and 386 DF,  p-value: &lt; 2.2e-16\n\n\nThe contrasts() function returns the coding that R uses for the dummy variables.\n\nattach(Carseats)\ncontrasts(ShelveLoc)\n\n       Good Medium\nBad       0      0\nGood      1      0\nMedium    0      1\n\n\nUse ?contrasts to learn about other contrasts, and how to set them.\nR has created a ShelveLocGood dummy variable that takes on a value of 1 if the shelving location is good, and 0 otherwise. It has also created a ShelveLocMedium dummy variable that equals 1 if the shelving location is medium, and 0 otherwise. A bad shelving location corresponds to a zero for each of the two dummy variables. The fact that the coefficient for ShelveLocGood in the regression output is positive indicates that a good shelving location is associated with high sales (relative to a bad location). And ShelveLocMedium has a smaller positive coefficient, indicating that a medium shelving location is associated with higher sales than a bad shelving location but lower sales than a good shelving location.\n\n\n\nAs we have seen, R comes with many useful functions, and still more functions are available by way of R libraries. However, we will often be interested in performing an operation for which no function is available. In this setting, we may want to write our own function. For instance, below we provide a simple function that reads in the ISLR2 and MASS libraries, called LoadLibraries(). Before we have created the function, R returns an error if we try to call it.\n\nLoadLibraries\n\nError in eval(expr, envir, enclos): object 'LoadLibraries' not found\n\nLoadLibraries()\n\nError in LoadLibraries(): could not find function \"LoadLibraries\"\n\n\nWe now create the function. Note that the + symbols are printed by R and should not be typed in. The { symbol informs R that multiple commands are about to be input. Hitting Enter after typing { will cause R to print the + symbol. We can then input as many commands as we wish, hitting {Enter} after each one. Finally the } symbol informs R that no further commands will be entered.\n\nLoadLibraries &lt;- function() {\n library(ISLR2)\n library(MASS)\n print(\"The libraries have been loaded.\")\n}\n\nNow if we type in LoadLibraries, R will tell us what is in the function.\n\nLoadLibraries\n\nfunction() {\n library(ISLR2)\n library(MASS)\n print(\"The libraries have been loaded.\")\n}\n\n\nIf we call the function, the libraries are loaded in and the print statement is output.\n\nLoadLibraries()\n\n[1] \"The libraries have been loaded.\""
  },
  {
    "objectID": "chapter3.html#libraries",
    "href": "chapter3.html#libraries",
    "title": "chapter3",
    "section": "",
    "text": "The library() function is used to load libraries, or groups of functions and data sets that are not included in the base R distribution. Basic functions that perform least squares linear regression and other simple analyses come standard with the base distribution, but more exotic functions require additional libraries. Here we load the MASS package, which is a very large collection of data sets and functions. We also load the ISLR2 package, which includes the data sets associated with this book.\n\nlibrary(MASS)\nlibrary(ISLR2)\n\nWarning: package 'ISLR2' was built under R version 4.4.1\n\n\n\nAttaching package: 'ISLR2'\n\n\nThe following object is masked from 'package:MASS':\n\n    Boston\n\n\nIf you receive an error message when loading any of these libraries, it likely indicates that the corresponding library has not yet been installed on your system. Some libraries, such as MASS, come with R and do not need to be separately installed on your computer. However, other packages, such as ISLR2, must be downloaded the first time they are used. This can be done directly from within R. For example, on a Windows system, select the Install package option under the Packages tab. After you select any mirror site, a list of available packages will appear. Simply select the package you wish to install and R will automatically download the package. Alternatively, this can be done at the R command line via install.packages(\"ISLR2\"). This installation only needs to be done the first time you use a package. However, the library() function must be called within each R session."
  },
  {
    "objectID": "chapter3.html#simple-linear-regression",
    "href": "chapter3.html#simple-linear-regression",
    "title": "chapter3",
    "section": "",
    "text": "The ISLR2 library contains the Boston data set, which records medv (median house value) for \\(506\\) census tracts in Boston. We will seek to predict medv using \\(12\\) predictors such as rmvar (average number of rooms per house), age (proportion of owner-occupied units built prior to 1940) and lstat (percent of households with low socioeconomic status).\n\nhead(Boston)\n\n     crim zn indus chas   nox    rm  age    dis rad tax ptratio lstat medv\n1 0.00632 18  2.31    0 0.538 6.575 65.2 4.0900   1 296    15.3  4.98 24.0\n2 0.02731  0  7.07    0 0.469 6.421 78.9 4.9671   2 242    17.8  9.14 21.6\n3 0.02729  0  7.07    0 0.469 7.185 61.1 4.9671   2 242    17.8  4.03 34.7\n4 0.03237  0  2.18    0 0.458 6.998 45.8 6.0622   3 222    18.7  2.94 33.4\n5 0.06905  0  2.18    0 0.458 7.147 54.2 6.0622   3 222    18.7  5.33 36.2\n6 0.02985  0  2.18    0 0.458 6.430 58.7 6.0622   3 222    18.7  5.21 28.7\n\n\nTo find out more about the data set, we can type ?Boston.\nWe will start by using the lm() function to fit a simple linear regression model, with medv as the response and lstat as the predictor. The basic syntax is lm(y ~ x, data), where y is the response, x is the predictor, and data is the data set in which these two variables are kept.\n\nlm.fit &lt;- lm(medv ~ lstat)\n\nError in eval(predvars, data, env): object 'medv' not found\n\n\nThe command causes an error because R does not know where to find the variables medv and lstat. The next line tells R that the variables are in Boston. If we attach Boston, the first line works fine because R now recognizes the variables.\n\nlm.fit &lt;- lm(medv ~ lstat, data = Boston)\nattach(Boston)\nlm.fit &lt;- lm(medv ~ lstat)\n\nIf we type lm.fit, some basic information about the model is output. For more detailed information, we use summary(lm.fit). This gives us \\(p\\)-values and standard errors for the coefficients, as well as the \\(R^2\\) statistic and \\(F\\)-statistic for the model.\n\nlm.fit\n\n\nCall:\nlm(formula = medv ~ lstat)\n\nCoefficients:\n(Intercept)        lstat  \n      34.55        -0.95  \n\nsummary(lm.fit)\n\n\nCall:\nlm(formula = medv ~ lstat)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-15.168  -3.990  -1.318   2.034  24.500 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 34.55384    0.56263   61.41   &lt;2e-16 ***\nlstat       -0.95005    0.03873  -24.53   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.216 on 504 degrees of freedom\nMultiple R-squared:  0.5441,    Adjusted R-squared:  0.5432 \nF-statistic: 601.6 on 1 and 504 DF,  p-value: &lt; 2.2e-16\n\n\nWe can use the names() function in order to find out what other pieces of information are stored in lm.fit. Although we can extract these quantities by name—e.g. lm.fit$coefficients—it is safer to use the extractor functions like coef() to access them.\n\nnames(lm.fit)\n\n [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"        \n\ncoef(lm.fit)\n\n(Intercept)       lstat \n 34.5538409  -0.9500494 \n\n\nIn order to obtain a confidence interval for the coefficient estimates, we can use the confint() command.\n\nconfint(lm.fit)\n\n                2.5 %     97.5 %\n(Intercept) 33.448457 35.6592247\nlstat       -1.026148 -0.8739505\n\n\nThe predict() function can be used to produce confidence intervals and prediction intervals for the prediction of medv for a given value of lstat.\n\npredict(lm.fit, data.frame(lstat = (c(5, 10, 15))),\n    interval = \"confidence\")\n\n       fit      lwr      upr\n1 29.80359 29.00741 30.59978\n2 25.05335 24.47413 25.63256\n3 20.30310 19.73159 20.87461\n\npredict(lm.fit, data.frame(lstat = (c(5, 10, 15))),\n    interval = \"prediction\")\n\n       fit       lwr      upr\n1 29.80359 17.565675 42.04151\n2 25.05335 12.827626 37.27907\n3 20.30310  8.077742 32.52846\n\n\nFor instance, the 95 % confidence interval associated with a lstat value of 10 is \\((24.47, 25.63)\\), and the 95 % prediction interval is \\((12.828, 37.28)\\). As expected, the confidence and prediction intervals are centered around the same point (a predicted value of \\(25.05\\) for medv when lstat equals 10), but the latter are substantially wider.\nWe will now plot medv and lstat along with the least squares regression line using the plot() and abline() functions.\n\nplot(lstat, medv)\nabline(lm.fit)\n\n\n\n\n\n\n\n\nThere is some evidence for non-linearity in the relationship between lstat and medv. We will explore this issue later in this lab.\nThe abline() function can be used to draw any line, not just the least squares regression line. To draw a line with intercept a and slope b, we type abline(a, b). Below we experiment with some additional settings for plotting lines and points. The lwd = 3 command causes the width of the regression line to be increased by a factor of 3; this works for the plot() and lines() functions also. We can also use the pch option to create different plotting symbols.\n\nplot(lstat, medv)\nabline(lm.fit, lwd = 3)\nabline(lm.fit, lwd = 3, col = \"red\")\n\n\n\n\n\n\n\nplot(lstat, medv, col = \"red\")\n\n\n\n\n\n\n\nplot(lstat, medv, pch = 20)\n\n\n\n\n\n\n\nplot(lstat, medv, pch = \"+\")\n\n\n\n\n\n\n\nplot(1:20, 1:20, pch = 1:20)\n\n\n\n\n\n\n\n\nNext we examine some diagnostic plots, several of which were discussed in Section 3.3.3. Four diagnostic plots are automatically produced by applying the plot() function directly to the output from lm(). In general, this command will produce one plot at a time, and hitting Enter will generate the next plot. However, it is often convenient to view all four plots together. We can achieve this by using the par() and mfrow() functions, which tell R to split the display screen into separate panels so that multiple plots can be viewed simultaneously. For example, par(mfrow = c(2, 2)) divides the plotting region into a \\(2 \\times 2\\) grid of panels.\n\npar(mfrow = c(2, 2))\nplot(lm.fit)\n\n\n\n\n\n\n\n\nAlternatively, we can compute the residuals from a linear regression fit using the residuals() function. The function rstudent() will return the studentized residuals, and we can use this function to plot the residuals against the fitted values.\n\nplot(predict(lm.fit), residuals(lm.fit))\n\n\n\n\n\n\n\nplot(predict(lm.fit), rstudent(lm.fit))\n\n\n\n\n\n\n\n\nOn the basis of the residual plots, there is some evidence of non-linearity. Leverage statistics can be computed for any number of predictors using the hatvalues() function.\n\nplot(hatvalues(lm.fit))\n\n\n\n\n\n\n\nwhich.max(hatvalues(lm.fit))\n\n375 \n375 \n\n\nThe which.max() function identifies the index of the largest element of a vector. In this case, it tells us which observation has the largest leverage statistic."
  },
  {
    "objectID": "chapter3.html#multiple-linear-regression",
    "href": "chapter3.html#multiple-linear-regression",
    "title": "chapter3",
    "section": "",
    "text": "In order to fit a multiple linear regression model using least squares, we again use the lm() function. The syntax lm(y ~ x1 + x2 + x3) is used to fit a model with three predictors, x1, x2, and x3. The summary() function now outputs the regression coefficients for all the predictors.\n\nlm.fit &lt;- lm(medv ~ lstat + age, data = Boston)\nsummary(lm.fit)\n\n\nCall:\nlm(formula = medv ~ lstat + age, data = Boston)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-15.981  -3.978  -1.283   1.968  23.158 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 33.22276    0.73085  45.458  &lt; 2e-16 ***\nlstat       -1.03207    0.04819 -21.416  &lt; 2e-16 ***\nage          0.03454    0.01223   2.826  0.00491 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.173 on 503 degrees of freedom\nMultiple R-squared:  0.5513,    Adjusted R-squared:  0.5495 \nF-statistic:   309 on 2 and 503 DF,  p-value: &lt; 2.2e-16\n\n\nThe Boston data set contains 12 variables, and so it would be cumbersome to have to type all of these in order to perform a regression using all of the predictors. Instead, we can use the following short-hand:\n\nlm.fit &lt;- lm(medv ~ ., data = Boston)\nsummary(lm.fit)\n\n\nCall:\nlm(formula = medv ~ ., data = Boston)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-15.1304  -2.7673  -0.5814   1.9414  26.2526 \n\nCoefficients:\n              Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  41.617270   4.936039   8.431 3.79e-16 ***\ncrim         -0.121389   0.033000  -3.678 0.000261 ***\nzn            0.046963   0.013879   3.384 0.000772 ***\nindus         0.013468   0.062145   0.217 0.828520    \nchas          2.839993   0.870007   3.264 0.001173 ** \nnox         -18.758022   3.851355  -4.870 1.50e-06 ***\nrm            3.658119   0.420246   8.705  &lt; 2e-16 ***\nage           0.003611   0.013329   0.271 0.786595    \ndis          -1.490754   0.201623  -7.394 6.17e-13 ***\nrad           0.289405   0.066908   4.325 1.84e-05 ***\ntax          -0.012682   0.003801  -3.337 0.000912 ***\nptratio      -0.937533   0.132206  -7.091 4.63e-12 ***\nlstat        -0.552019   0.050659 -10.897  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.798 on 493 degrees of freedom\nMultiple R-squared:  0.7343,    Adjusted R-squared:  0.7278 \nF-statistic: 113.5 on 12 and 493 DF,  p-value: &lt; 2.2e-16\n\n\nWe can access the individual components of a summary object by name (type ?summary.lm to see what is available). Hence summary(lm.fit)$r.sq gives us the \\(R^2\\), and summary(lm.fit)$sigma gives us the RSE. The vif() function, part of the car package, can be used to compute variance inflation factors. Most VIF’s are low to moderate for this data. The car package is not part of the base R installation so it must be downloaded the first time you use it via the install.packages() function in R.\n\nlibrary(car)\n\nLoading required package: carData\n\nvif(lm.fit)\n\n    crim       zn    indus     chas      nox       rm      age      dis \n1.767486 2.298459 3.987181 1.071168 4.369093 1.912532 3.088232 3.954037 \n     rad      tax  ptratio    lstat \n7.445301 9.002158 1.797060 2.870777 \n\n\nWhat if we would like to perform a regression using all of the variables but one? For example, in the above regression output, age has a high \\(p\\)-value. So we may wish to run a regression excluding this predictor. The following syntax results in a regression using all predictors except age.\n\nlm.fit1 &lt;- lm(medv ~ . - age, data = Boston)\nsummary(lm.fit1)\n\n\nCall:\nlm(formula = medv ~ . - age, data = Boston)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-15.1851  -2.7330  -0.6116   1.8555  26.3838 \n\nCoefficients:\n              Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  41.525128   4.919684   8.441 3.52e-16 ***\ncrim         -0.121426   0.032969  -3.683 0.000256 ***\nzn            0.046512   0.013766   3.379 0.000785 ***\nindus         0.013451   0.062086   0.217 0.828577    \nchas          2.852773   0.867912   3.287 0.001085 ** \nnox         -18.485070   3.713714  -4.978 8.91e-07 ***\nrm            3.681070   0.411230   8.951  &lt; 2e-16 ***\ndis          -1.506777   0.192570  -7.825 3.12e-14 ***\nrad           0.287940   0.066627   4.322 1.87e-05 ***\ntax          -0.012653   0.003796  -3.333 0.000923 ***\nptratio      -0.934649   0.131653  -7.099 4.39e-12 ***\nlstat        -0.547409   0.047669 -11.483  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.794 on 494 degrees of freedom\nMultiple R-squared:  0.7343,    Adjusted R-squared:  0.7284 \nF-statistic: 124.1 on 11 and 494 DF,  p-value: &lt; 2.2e-16\n\n\nAlternatively, the update() function can be used.\n\nlm.fit1 &lt;- update(lm.fit, ~ . - age)"
  },
  {
    "objectID": "chapter3.html#interaction-terms",
    "href": "chapter3.html#interaction-terms",
    "title": "chapter3",
    "section": "",
    "text": "It is easy to include interaction terms in a linear model using the lm() function. The syntax lstat:age tells R to include an interaction term between lstat and age. The syntax lstat * age simultaneously includes lstat, age, and the interaction term lstat\\(\\times\\)age as predictors; it is a shorthand for lstat + age + lstat:age. %We can also pass in transformed versions of the predictors.\n\nsummary(lm(medv ~ lstat * age, data = Boston))\n\n\nCall:\nlm(formula = medv ~ lstat * age, data = Boston)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-15.806  -4.045  -1.333   2.085  27.552 \n\nCoefficients:\n              Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 36.0885359  1.4698355  24.553  &lt; 2e-16 ***\nlstat       -1.3921168  0.1674555  -8.313 8.78e-16 ***\nage         -0.0007209  0.0198792  -0.036   0.9711    \nlstat:age    0.0041560  0.0018518   2.244   0.0252 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.149 on 502 degrees of freedom\nMultiple R-squared:  0.5557,    Adjusted R-squared:  0.5531 \nF-statistic: 209.3 on 3 and 502 DF,  p-value: &lt; 2.2e-16"
  },
  {
    "objectID": "chapter3.html#non-linear-transformations-of-the-predictors",
    "href": "chapter3.html#non-linear-transformations-of-the-predictors",
    "title": "chapter3",
    "section": "",
    "text": "The lm() function can also accommodate non-linear transformations of the predictors. For instance, given a predictor \\(X\\), we can create a predictor \\(X^2\\) using I(X^2). The function I() is needed since the ^ has a special meaning in a formula object; wrapping as we do allows the standard usage in R, which is to raise X to the power 2. We now perform a regression of medv onto lstat and lstat^2.\n\nlm.fit2 &lt;- lm(medv ~ lstat + I(lstat^2))\nsummary(lm.fit2)\n\n\nCall:\nlm(formula = medv ~ lstat + I(lstat^2))\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-15.2834  -3.8313  -0.5295   2.3095  25.4148 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 42.862007   0.872084   49.15   &lt;2e-16 ***\nlstat       -2.332821   0.123803  -18.84   &lt;2e-16 ***\nI(lstat^2)   0.043547   0.003745   11.63   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 5.524 on 503 degrees of freedom\nMultiple R-squared:  0.6407,    Adjusted R-squared:  0.6393 \nF-statistic: 448.5 on 2 and 503 DF,  p-value: &lt; 2.2e-16\n\n\nThe near-zero \\(p\\)-value associated with the quadratic term suggests that it leads to an improved model. We use the anova() function to further quantify the extent to which the quadratic fit is superior to the linear fit.\n\nlm.fit &lt;- lm(medv ~ lstat)\nanova(lm.fit, lm.fit2)\n\nAnalysis of Variance Table\n\nModel 1: medv ~ lstat\nModel 2: medv ~ lstat + I(lstat^2)\n  Res.Df   RSS Df Sum of Sq     F    Pr(&gt;F)    \n1    504 19472                                 \n2    503 15347  1    4125.1 135.2 &lt; 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nHere Model 1 represents the linear submodel containing only one predictor, lstat, while Model 2 corresponds to the larger quadratic model that has two predictors, lstat and lstat^2. The anova() function performs a hypothesis test comparing the two models. The null hypothesis is that the two models fit the data equally well, and the alternative hypothesis is that the full model is superior. Here the \\(F\\)-statistic is \\(135\\) and the associated \\(p\\)-value is virtually zero. This provides very clear evidence that the model containing the predictors lstat and lstat^2 is far superior to the model that only contains the predictor lstat. This is not surprising, since earlier we saw evidence for non-linearity in the relationship between medv and lstat. If we type\n\npar(mfrow = c(2, 2))\nplot(lm.fit2)\n\n\n\n\n\n\n\n\nthen we see that when the lstat^2 term is included in the model, there is little discernible pattern in the residuals.\nIn order to create a cubic fit, we can include a predictor of the form I(X^3). However, this approach can start to get cumbersome for higher-order polynomials. A better approach involves using the poly() function to create the polynomial within lm(). For example, the following command produces a fifth-order polynomial fit:\n\nlm.fit5 &lt;- lm(medv ~ poly(lstat, 5))\nsummary(lm.fit5)\n\n\nCall:\nlm(formula = medv ~ poly(lstat, 5))\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-13.5433  -3.1039  -0.7052   2.0844  27.1153 \n\nCoefficients:\n                 Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)       22.5328     0.2318  97.197  &lt; 2e-16 ***\npoly(lstat, 5)1 -152.4595     5.2148 -29.236  &lt; 2e-16 ***\npoly(lstat, 5)2   64.2272     5.2148  12.316  &lt; 2e-16 ***\npoly(lstat, 5)3  -27.0511     5.2148  -5.187 3.10e-07 ***\npoly(lstat, 5)4   25.4517     5.2148   4.881 1.42e-06 ***\npoly(lstat, 5)5  -19.2524     5.2148  -3.692 0.000247 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 5.215 on 500 degrees of freedom\nMultiple R-squared:  0.6817,    Adjusted R-squared:  0.6785 \nF-statistic: 214.2 on 5 and 500 DF,  p-value: &lt; 2.2e-16\n\n\nThis suggests that including additional polynomial terms, up to fifth order, leads to an improvement in the model fit! However, further investigation of the data reveals that no polynomial terms beyond fifth order have significant \\(p\\)-values in a regression fit.\nBy default, the poly() function orthogonalizes the predictors: this means that the features output by this function are not simply a sequence of powers of the argument. However, a linear model applied to the output of the poly() function will have the same fitted values as a linear model applied to the raw polynomials (although the coefficient estimates, standard errors, and p-values will differ). In order to obtain the raw polynomials from the poly() function, the argument raw = TRUE must be used.\nOf course, we are in no way restricted to using polynomial transformations of the predictors. Here we try a log transformation.\n\nsummary(lm(medv ~ log(rm), data = Boston))\n\n\nCall:\nlm(formula = medv ~ log(rm), data = Boston)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-19.487  -2.875  -0.104   2.837  39.816 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  -76.488      5.028  -15.21   &lt;2e-16 ***\nlog(rm)       54.055      2.739   19.73   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 6.915 on 504 degrees of freedom\nMultiple R-squared:  0.4358,    Adjusted R-squared:  0.4347 \nF-statistic: 389.3 on 1 and 504 DF,  p-value: &lt; 2.2e-16"
  },
  {
    "objectID": "chapter3.html#qualitative-predictors",
    "href": "chapter3.html#qualitative-predictors",
    "title": "chapter3",
    "section": "",
    "text": "We will now examine the Carseats data, which is part of the ISLR2 library. We will attempt to predict Sales (child car seat sales) in \\(400\\) locations based on a number of predictors.\n\nhead(Carseats)\n\n  Sales CompPrice Income Advertising Population Price ShelveLoc Age Education\n1  9.50       138     73          11        276   120       Bad  42        17\n2 11.22       111     48          16        260    83      Good  65        10\n3 10.06       113     35          10        269    80    Medium  59        12\n4  7.40       117    100           4        466    97    Medium  55        14\n5  4.15       141     64           3        340   128       Bad  38        13\n6 10.81       124    113          13        501    72       Bad  78        16\n  Urban  US\n1   Yes Yes\n2   Yes Yes\n3   Yes Yes\n4   Yes Yes\n5   Yes  No\n6    No Yes\n\n\nThe Carseats data includes qualitative predictors such as shelveloc, an indicator of the quality of the shelving location—that is, the space within a store in which the car seat is displayed—at each location. The predictor shelveloc takes on three possible values: Bad, Medium, and Good. Given a qualitative variable such as shelveloc, R generates dummy variables automatically. Below we fit a multiple regression model that includes some interaction terms.\n\nlm.fit &lt;- lm(Sales ~ . + Income:Advertising + Price:Age, \n    data = Carseats)\nsummary(lm.fit)\n\n\nCall:\nlm(formula = Sales ~ . + Income:Advertising + Price:Age, data = Carseats)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.9208 -0.7503  0.0177  0.6754  3.3413 \n\nCoefficients:\n                     Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)         6.5755654  1.0087470   6.519 2.22e-10 ***\nCompPrice           0.0929371  0.0041183  22.567  &lt; 2e-16 ***\nIncome              0.0108940  0.0026044   4.183 3.57e-05 ***\nAdvertising         0.0702462  0.0226091   3.107 0.002030 ** \nPopulation          0.0001592  0.0003679   0.433 0.665330    \nPrice              -0.1008064  0.0074399 -13.549  &lt; 2e-16 ***\nShelveLocGood       4.8486762  0.1528378  31.724  &lt; 2e-16 ***\nShelveLocMedium     1.9532620  0.1257682  15.531  &lt; 2e-16 ***\nAge                -0.0579466  0.0159506  -3.633 0.000318 ***\nEducation          -0.0208525  0.0196131  -1.063 0.288361    \nUrbanYes            0.1401597  0.1124019   1.247 0.213171    \nUSYes              -0.1575571  0.1489234  -1.058 0.290729    \nIncome:Advertising  0.0007510  0.0002784   2.698 0.007290 ** \nPrice:Age           0.0001068  0.0001333   0.801 0.423812    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.011 on 386 degrees of freedom\nMultiple R-squared:  0.8761,    Adjusted R-squared:  0.8719 \nF-statistic:   210 on 13 and 386 DF,  p-value: &lt; 2.2e-16\n\n\nThe contrasts() function returns the coding that R uses for the dummy variables.\n\nattach(Carseats)\ncontrasts(ShelveLoc)\n\n       Good Medium\nBad       0      0\nGood      1      0\nMedium    0      1\n\n\nUse ?contrasts to learn about other contrasts, and how to set them.\nR has created a ShelveLocGood dummy variable that takes on a value of 1 if the shelving location is good, and 0 otherwise. It has also created a ShelveLocMedium dummy variable that equals 1 if the shelving location is medium, and 0 otherwise. A bad shelving location corresponds to a zero for each of the two dummy variables. The fact that the coefficient for ShelveLocGood in the regression output is positive indicates that a good shelving location is associated with high sales (relative to a bad location). And ShelveLocMedium has a smaller positive coefficient, indicating that a medium shelving location is associated with higher sales than a bad shelving location but lower sales than a good shelving location."
  },
  {
    "objectID": "chapter3.html#writing-functions",
    "href": "chapter3.html#writing-functions",
    "title": "chapter3",
    "section": "",
    "text": "As we have seen, R comes with many useful functions, and still more functions are available by way of R libraries. However, we will often be interested in performing an operation for which no function is available. In this setting, we may want to write our own function. For instance, below we provide a simple function that reads in the ISLR2 and MASS libraries, called LoadLibraries(). Before we have created the function, R returns an error if we try to call it.\n\nLoadLibraries\n\nError in eval(expr, envir, enclos): object 'LoadLibraries' not found\n\nLoadLibraries()\n\nError in LoadLibraries(): could not find function \"LoadLibraries\"\n\n\nWe now create the function. Note that the + symbols are printed by R and should not be typed in. The { symbol informs R that multiple commands are about to be input. Hitting Enter after typing { will cause R to print the + symbol. We can then input as many commands as we wish, hitting {Enter} after each one. Finally the } symbol informs R that no further commands will be entered.\n\nLoadLibraries &lt;- function() {\n library(ISLR2)\n library(MASS)\n print(\"The libraries have been loaded.\")\n}\n\nNow if we type in LoadLibraries, R will tell us what is in the function.\n\nLoadLibraries\n\nfunction() {\n library(ISLR2)\n library(MASS)\n print(\"The libraries have been loaded.\")\n}\n\n\nIf we call the function, the libraries are loaded in and the print statement is output.\n\nLoadLibraries()\n\n[1] \"The libraries have been loaded.\""
  },
  {
    "objectID": "chapter4.html",
    "href": "chapter4.html",
    "title": "chapter4",
    "section": "",
    "text": "We will begin by examining some numerical and graphical summaries of the Smarket data, which is part of the ISLR2 library. This data set consists of percentage returns for the S&P 500 stock index over \\(1,250\\) days, from the beginning of 2001 until the end of 2005. For each date, we have recorded the percentage returns for each of the five previous trading days, lagone through lagfive. We have also recorded volume (the number of shares traded on the previous day, in billions), Today (the percentage return on the date in question) and direction (whether the market was Up or Down on this date). Our goal is to predict direction (a qualitative response) using the other features.\n\nlibrary(ISLR2)\n\nWarning: package 'ISLR2' was built under R version 4.4.1\n\nnames(Smarket)\n\n[1] \"Year\"      \"Lag1\"      \"Lag2\"      \"Lag3\"      \"Lag4\"      \"Lag5\"     \n[7] \"Volume\"    \"Today\"     \"Direction\"\n\ndim(Smarket)\n\n[1] 1250    9\n\nsummary(Smarket)\n\n      Year           Lag1                Lag2                Lag3          \n Min.   :2001   Min.   :-4.922000   Min.   :-4.922000   Min.   :-4.922000  \n 1st Qu.:2002   1st Qu.:-0.639500   1st Qu.:-0.639500   1st Qu.:-0.640000  \n Median :2003   Median : 0.039000   Median : 0.039000   Median : 0.038500  \n Mean   :2003   Mean   : 0.003834   Mean   : 0.003919   Mean   : 0.001716  \n 3rd Qu.:2004   3rd Qu.: 0.596750   3rd Qu.: 0.596750   3rd Qu.: 0.596750  \n Max.   :2005   Max.   : 5.733000   Max.   : 5.733000   Max.   : 5.733000  \n      Lag4                Lag5              Volume           Today          \n Min.   :-4.922000   Min.   :-4.92200   Min.   :0.3561   Min.   :-4.922000  \n 1st Qu.:-0.640000   1st Qu.:-0.64000   1st Qu.:1.2574   1st Qu.:-0.639500  \n Median : 0.038500   Median : 0.03850   Median :1.4229   Median : 0.038500  \n Mean   : 0.001636   Mean   : 0.00561   Mean   :1.4783   Mean   : 0.003138  \n 3rd Qu.: 0.596750   3rd Qu.: 0.59700   3rd Qu.:1.6417   3rd Qu.: 0.596750  \n Max.   : 5.733000   Max.   : 5.73300   Max.   :3.1525   Max.   : 5.733000  \n Direction \n Down:602  \n Up  :648  \n           \n           \n           \n           \n\npairs(Smarket)\n\n\n\n\n\n\n\n\nThe cor() function produces a matrix that contains all of the pairwise correlations among the predictors in a data set. The first command below gives an error message because the direction variable is qualitative.\n\ncor(Smarket)\n\nError in cor(Smarket): 'x' must be numeric\n\ncor(Smarket[, -9])\n\n             Year         Lag1         Lag2         Lag3         Lag4\nYear   1.00000000  0.029699649  0.030596422  0.033194581  0.035688718\nLag1   0.02969965  1.000000000 -0.026294328 -0.010803402 -0.002985911\nLag2   0.03059642 -0.026294328  1.000000000 -0.025896670 -0.010853533\nLag3   0.03319458 -0.010803402 -0.025896670  1.000000000 -0.024051036\nLag4   0.03568872 -0.002985911 -0.010853533 -0.024051036  1.000000000\nLag5   0.02978799 -0.005674606 -0.003557949 -0.018808338 -0.027083641\nVolume 0.53900647  0.040909908 -0.043383215 -0.041823686 -0.048414246\nToday  0.03009523 -0.026155045 -0.010250033 -0.002447647 -0.006899527\n               Lag5      Volume        Today\nYear    0.029787995  0.53900647  0.030095229\nLag1   -0.005674606  0.04090991 -0.026155045\nLag2   -0.003557949 -0.04338321 -0.010250033\nLag3   -0.018808338 -0.04182369 -0.002447647\nLag4   -0.027083641 -0.04841425 -0.006899527\nLag5    1.000000000 -0.02200231 -0.034860083\nVolume -0.022002315  1.00000000  0.014591823\nToday  -0.034860083  0.01459182  1.000000000\n\n\nAs one would expect, the correlations between the lag variables and today’s returns are close to zero. In other words, there appears to be little correlation between today’s returns and previous days’ returns. The only substantial correlation is between Year and volume. By plotting the data, which is ordered chronologically, we see that volume is increasing over time. In other words, the average number of shares traded daily increased from 2001 to 2005.\n\nattach(Smarket)\nplot(Volume)\n\n\n\n\n\n\n\n\n\n\n\nNext, we will fit a logistic regression model in order to predict direction using lagone through lagfive and volume. The glm() function can be used to fit many types of generalized linear models, including logistic regression. The syntax of the glm() function is similar to that of lm(), except that we must pass in the argument family = binomial in order to tell R to run a logistic regression rather than some other type of generalized linear model.\n\nglm.fits &lt;- glm(\n    Direction ~ Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + Volume,\n    data = Smarket, family = binomial\n  )\nsummary(glm.fits)\n\n\nCall:\nglm(formula = Direction ~ Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + \n    Volume, family = binomial, data = Smarket)\n\nCoefficients:\n             Estimate Std. Error z value Pr(&gt;|z|)\n(Intercept) -0.126000   0.240736  -0.523    0.601\nLag1        -0.073074   0.050167  -1.457    0.145\nLag2        -0.042301   0.050086  -0.845    0.398\nLag3         0.011085   0.049939   0.222    0.824\nLag4         0.009359   0.049974   0.187    0.851\nLag5         0.010313   0.049511   0.208    0.835\nVolume       0.135441   0.158360   0.855    0.392\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 1731.2  on 1249  degrees of freedom\nResidual deviance: 1727.6  on 1243  degrees of freedom\nAIC: 1741.6\n\nNumber of Fisher Scoring iterations: 3\n\n\nThe smallest \\(p\\)-value here is associated with lagone. The negative coefficient for this predictor suggests that if the market had a positive return yesterday, then it is less likely to go up today. However, at a value of \\(0.15\\), the \\(p\\)-value is still relatively large, and so there is no clear evidence of a real association between lagone and direction.\nWe use the coef() function in order to access just the coefficients for this fitted model. We can also use the summary() function to access particular aspects of the fitted model, such as the \\(p\\)-values for the coefficients.\n\ncoef(glm.fits)\n\n (Intercept)         Lag1         Lag2         Lag3         Lag4         Lag5 \n-0.126000257 -0.073073746 -0.042301344  0.011085108  0.009358938  0.010313068 \n      Volume \n 0.135440659 \n\nsummary(glm.fits)$coef\n\n                Estimate Std. Error    z value  Pr(&gt;|z|)\n(Intercept) -0.126000257 0.24073574 -0.5233966 0.6006983\nLag1        -0.073073746 0.05016739 -1.4565986 0.1452272\nLag2        -0.042301344 0.05008605 -0.8445733 0.3983491\nLag3         0.011085108 0.04993854  0.2219750 0.8243333\nLag4         0.009358938 0.04997413  0.1872757 0.8514445\nLag5         0.010313068 0.04951146  0.2082966 0.8349974\nVolume       0.135440659 0.15835970  0.8552723 0.3924004\n\nsummary(glm.fits)$coef[, 4]\n\n(Intercept)        Lag1        Lag2        Lag3        Lag4        Lag5 \n  0.6006983   0.1452272   0.3983491   0.8243333   0.8514445   0.8349974 \n     Volume \n  0.3924004 \n\n\nThe predict() function can be used to predict the probability that the market will go up, given values of the predictors. The type = \"response\" option tells R to output probabilities of the form \\(P(Y=1|X)\\), as opposed to other information such as the logit. If no data set is supplied to the predict() function, then the probabilities are computed for the training data that was used to fit the logistic regression model. Here we have printed only the first ten probabilities. We know that these values correspond to the probability of the market going up, rather than down, because the contrasts() function indicates that R has created a dummy variable with a 1 for Up.\n\nglm.probs &lt;- predict(glm.fits, type = \"response\")\nglm.probs[1:10]\n\n        1         2         3         4         5         6         7         8 \n0.5070841 0.4814679 0.4811388 0.5152224 0.5107812 0.5069565 0.4926509 0.5092292 \n        9        10 \n0.5176135 0.4888378 \n\ncontrasts(Direction)\n\n     Up\nDown  0\nUp    1\n\n\nIn order to make a prediction as to whether the market will go up or down on a particular day, we must convert these predicted probabilities into class labels, Up or Down. The following two commands create a vector of class predictions based on whether the predicted probability of a market increase is greater than or less than \\(0.5\\).\n\nglm.pred &lt;- rep(\"Down\", 1250)\nglm.pred[glm.probs &gt; .5] = \"Up\"\n\nThe first command creates a vector of 1,250 Down elements. The second line transforms to Up all of the elements for which the predicted probability of a market increase exceeds \\(0.5\\). Given these predictions, the table() function can be used to produce a confusion matrix in order to determine how many observations were correctly or incorrectly classified.\n\ntable(glm.pred, Direction)\n\n        Direction\nglm.pred Down  Up\n    Down  145 141\n    Up    457 507\n\n(507 + 145) / 1250\n\n[1] 0.5216\n\nmean(glm.pred == Direction)\n\n[1] 0.5216\n\n\nThe diagonal elements of the confusion matrix indicate correct predictions, while the off-diagonals represent incorrect predictions. Hence our model correctly predicted that the market would go up on \\(507\\) days and that it would go down on \\(145\\) days, for a total of \\(507+145 = 652\\) correct predictions. The mean() function can be used to compute the fraction of days for which the prediction was correct. In this case, logistic regression correctly predicted the movement of the market \\(52.2\\) % of the time.\nAt first glance, it appears that the logistic regression model is working a little better than random guessing. However, this result is misleading because we trained and tested the model on the same set of \\(1,250\\) observations. In other words, \\(100\\%-52.2\\%=47.8\\%\\), is the training error rate. As we have seen previously, the training error rate is often overly optimistic—it tends to underestimate the test error rate. In order to better assess the accuracy of the logistic regression model in this setting, we can fit the model using part of the data, and then examine how well it predicts the held out data. This will yield a more realistic error rate, in the sense that in practice we will be interested in our model’s performance not on the data that we used to fit the model, but rather on days in the future for which the market’s movements are unknown.\nTo implement this strategy, we will first create a vector corresponding to the observations from 2001 through 2004. We will then use this vector to create a held out data set of observations from 2005.\n\ntrain &lt;- (Year &lt; 2005)\nSmarket.2005 &lt;- Smarket[!train, ]\ndim(Smarket.2005)\n\n[1] 252   9\n\nDirection.2005 &lt;- Direction[!train]\n\nThe object train is a vector of \\(1{,}250\\) elements, corresponding to the observations in our data set. The elements of the vector that correspond to observations that occurred before 2005 are set to TRUE, whereas those that correspond to observations in 2005 are set to FALSE. The object train is a Boolean vector, since its elements are TRUE and FALSE. Boolean vectors can be used to obtain a subset of the rows or columns of a matrix. For instance, the command Smarket[train, ] would pick out a submatrix of the stock market data set, corresponding only to the dates before 2005, since those are the ones for which the elements of train are TRUE. The ! symbol can be used to reverse all of the elements of a Boolean vector. That is, !train is a vector similar to train, except that the elements that are TRUE in train get swapped to FALSE in !train, and the elements that are FALSE in train get swapped to TRUE in !train. Therefore, Smarket[!train, ] yields a submatrix of the stock market data containing only the observations for which train is FALSE—that is, the observations with dates in 2005. The output above indicates that there are 252 such observations.\nWe now fit a logistic regression model using only the subset of the observations that correspond to dates before 2005, using the subset argument. We then obtain predicted probabilities of the stock market going up for each of the days in our test set—that is, for the days in 2005.\n\nglm.fits &lt;- glm(\n    Direction ~ Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + Volume,\n    data = Smarket, family = binomial, subset = train\n  )\nglm.probs &lt;- predict(glm.fits, Smarket.2005,\n    type = \"response\")\n\nNotice that we have trained and tested our model on two completely separate data sets: training was performed using only the dates before 2005, and testing was performed using only the dates in 2005. Finally, we compute the predictions for 2005 and compare them to the actual movements of the market over that time period.\n\nglm.pred &lt;- rep(\"Down\", 252)\nglm.pred[glm.probs &gt; .5] &lt;- \"Up\"\ntable(glm.pred, Direction.2005)\n\n        Direction.2005\nglm.pred Down Up\n    Down   77 97\n    Up     34 44\n\nmean(glm.pred == Direction.2005)\n\n[1] 0.4801587\n\nmean(glm.pred != Direction.2005)\n\n[1] 0.5198413\n\n\nThe != notation means not equal to, and so the last command computes the test set error rate. The results are rather disappointing: the test error rate is \\(52\\) %, which is worse than random guessing! Of course this result is not all that surprising, given that one would not generally expect to be able to use previous days’ returns to predict future market performance. (After all, if it were possible to do so, then the authors of this book would be out striking it rich rather than writing a statistics textbook.)\nWe recall that the logistic regression model had very underwhelming \\(p\\)-values associated with all of the predictors, and that the smallest \\(p\\)-value, though not very small, corresponded to lagone. Perhaps by removing the variables that appear not to be helpful in predicting direction, we can obtain a more effective model. After all, using predictors that have no relationship with the response tends to cause a deterioration in the test error rate (since such predictors cause an increase in variance without a corresponding decrease in bias), and so removing such predictors may in turn yield an improvement. Below we have refit the logistic regression using just lagone and lagtwo, which seemed to have the highest predictive power in the original logistic regression model.\n\nglm.fits &lt;- glm(Direction ~ Lag1 + Lag2, data = Smarket,\n    family = binomial, subset = train)\nglm.probs &lt;- predict(glm.fits, Smarket.2005,\n    type = \"response\")\nglm.pred &lt;- rep(\"Down\", 252)\nglm.pred[glm.probs &gt; .5] &lt;- \"Up\"\ntable(glm.pred, Direction.2005)\n\n        Direction.2005\nglm.pred Down  Up\n    Down   35  35\n    Up     76 106\n\nmean(glm.pred == Direction.2005)\n\n[1] 0.5595238\n\n106 / (106 + 76)\n\n[1] 0.5824176\n\n\nNow the results appear to be a little better: \\(56\\%\\) of the daily movements have been correctly predicted. It is worth noting that in this case, a much simpler strategy of predicting that the market will increase every day will also be correct \\(56\\%\\) of the time! Hence, in terms of overall error rate, the logistic regression method is no better than the naive approach. However, the confusion matrix shows that on days when logistic regression predicts an increase in the market, it has a \\(58\\%\\) accuracy rate. This suggests a possible trading strategy of buying on days when the model predicts an increasing market, and avoiding trades on days when a decrease is predicted. Of course one would need to investigate more carefully whether this small improvement was real or just due to random chance.\nSuppose that we want to predict the returns associated with particular values of lagone and lagtwo. In particular, we want to predict direction on a day when lagone and lagtwo equal 1.2 and~1.1, respectively, and on a day when they equal 1.5 and $-$0.8. We do this using the predict() function.\n\npredict(glm.fits,\n    newdata =\n      data.frame(Lag1 = c(1.2, 1.5),  Lag2 = c(1.1, -0.8)),\n    type = \"response\"\n  )\n\n        1         2 \n0.4791462 0.4960939 \n\n\n\n\n\nNow we will perform LDA on the Smarket data. In R, we fit an LDA model using the lda() function, which is part of the MASS library. Notice that the syntax for the lda() function is identical to that of lm(), and to that of glm() except for the absence of the family option. We fit the model using only the observations before 2005.\n\nlibrary(MASS)\n\n\nAttaching package: 'MASS'\n\n\nThe following object is masked from 'package:ISLR2':\n\n    Boston\n\nlda.fit &lt;- lda(Direction ~ Lag1 + Lag2, data = Smarket,\n    subset = train)\nlda.fit\n\nCall:\nlda(Direction ~ Lag1 + Lag2, data = Smarket, subset = train)\n\nPrior probabilities of groups:\n    Down       Up \n0.491984 0.508016 \n\nGroup means:\n            Lag1        Lag2\nDown  0.04279022  0.03389409\nUp   -0.03954635 -0.03132544\n\nCoefficients of linear discriminants:\n            LD1\nLag1 -0.6420190\nLag2 -0.5135293\n\nplot(lda.fit)\n\n\n\n\n\n\n\n\nThe LDA output indicates that \\(\\hat\\pi_1=0.492\\) and \\(\\hat\\pi_2=0.508\\); in other words, \\(49.2\\) % of the training observations correspond to days during which the market went down. It also provides the group means; these are the average of each predictor within each class, and are used by LDA as estimates of \\(\\mu_k\\). These suggest that there is a tendency for the previous 2~days’ returns to be negative on days when the market increases, and a tendency for the previous days’ returns to be positive on days when the market declines. The coefficients of linear discriminants output provides the linear combination of lagone and lagtwo that are used to form the LDA decision rule. In other words, these are the multipliers of the elements of \\(X=x\\) in (4.24). If $-0.642 \\(`lagone`\\) - 0.514 $lagtwo is large, then the LDA classifier will predict a market increase, and if it is small, then the LDA classifier will predict a market decline.\nThe plot() function produces plots of the linear discriminants, obtained by computing $-0.642 \\(`lagone`\\) - 0.514 $lagtwo for each of the training observations. The Up and Down observations are displayed separately.\nThe predict() function returns a list with three elements. The first element, class, contains LDA’s predictions about the movement of the market. The second element, posterior, is a matrix whose \\(k\\)th column contains the posterior probability that the corresponding observation belongs to the \\(k\\)th class, computed from (4.15). Finally, x contains the linear discriminants, described earlier.\n\nlda.pred &lt;- predict(lda.fit, Smarket.2005)\nnames(lda.pred)\n\n[1] \"class\"     \"posterior\" \"x\"        \n\n\nAs we observed in Section 4.5, the LDA and logistic regression predictions are almost identical.\n\nlda.class &lt;- lda.pred$class\ntable(lda.class, Direction.2005)\n\n         Direction.2005\nlda.class Down  Up\n     Down   35  35\n     Up     76 106\n\nmean(lda.class == Direction.2005)\n\n[1] 0.5595238\n\n\nApplying a \\(50\\) % threshold to the posterior probabilities allows us to recreate the predictions contained in lda.pred$class.\n\nsum(lda.pred$posterior[, 1] &gt;= .5)\n\n[1] 70\n\nsum(lda.pred$posterior[, 1] &lt; .5)\n\n[1] 182\n\n\nNotice that the posterior probability output by the model corresponds to the probability that the market will decrease:\n\nlda.pred$posterior[1:20, 1]\n\n      999      1000      1001      1002      1003      1004      1005      1006 \n0.4901792 0.4792185 0.4668185 0.4740011 0.4927877 0.4938562 0.4951016 0.4872861 \n     1007      1008      1009      1010      1011      1012      1013      1014 \n0.4907013 0.4844026 0.4906963 0.5119988 0.4895152 0.4706761 0.4744593 0.4799583 \n     1015      1016      1017      1018 \n0.4935775 0.5030894 0.4978806 0.4886331 \n\nlda.class[1:20]\n\n [1] Up   Up   Up   Up   Up   Up   Up   Up   Up   Up   Up   Down Up   Up   Up  \n[16] Up   Up   Down Up   Up  \nLevels: Down Up\n\n\nIf we wanted to use a posterior probability threshold other than \\(50\\) % in order to make predictions, then we could easily do so. For instance, suppose that we wish to predict a market decrease only if we are very certain that the market will indeed decrease on that day—say, if the posterior probability is at least \\(90\\) %.\n\nsum(lda.pred$posterior[, 1] &gt; .9)\n\n[1] 0\n\n\nNo days in 2005 meet that threshold! In fact, the greatest posterior probability of decrease in all of 2005 was \\(52.02\\) %.\n\n\n\nWe will now fit a QDA model to the Smarket data. QDA is implemented in R using the qda() function, which is also part of the MASS library. The syntax is identical to that of lda().\n\nqda.fit &lt;- qda(Direction ~ Lag1 + Lag2, data = Smarket,\n    subset = train)\nqda.fit\n\nCall:\nqda(Direction ~ Lag1 + Lag2, data = Smarket, subset = train)\n\nPrior probabilities of groups:\n    Down       Up \n0.491984 0.508016 \n\nGroup means:\n            Lag1        Lag2\nDown  0.04279022  0.03389409\nUp   -0.03954635 -0.03132544\n\n\nThe output contains the group means. But it does not contain the coefficients of the linear discriminants, because the QDA classifier involves a quadratic, rather than a linear, function of the predictors. The predict() function works in exactly the same fashion as for LDA.\n\nqda.class &lt;- predict(qda.fit, Smarket.2005)$class\ntable(qda.class, Direction.2005)\n\n         Direction.2005\nqda.class Down  Up\n     Down   30  20\n     Up     81 121\n\nmean(qda.class == Direction.2005)\n\n[1] 0.5992063\n\n\nInterestingly, the QDA predictions are accurate almost \\(60\\) % of the time, even though the 2005 data was not used to fit the model. This level of accuracy is quite impressive for stock market data, which is known to be quite hard to model accurately. This suggests that the quadratic form assumed by QDA may capture the true relationship more accurately than the linear forms assumed by LDA and logistic regression. However, we recommend evaluating this method’s performance on a larger test set before betting that this approach will consistently beat the market!\n\n\n\nNext, we fit a naive Bayes model to the Smarket data. Naive Bayes is implemented in R using the naiveBayes() function, which is part of the e1071 library. The syntax is identical to that of lda() and qda(). By default, this implementation of the naive Bayes classifier models each quantitative feature using a Gaussian distribution. However, a kernel density method can also be used to estimate the distributions.\n\nlibrary(e1071)\nnb.fit &lt;- naiveBayes(Direction ~ Lag1 + Lag2, data = Smarket,\n    subset = train)\nnb.fit\n\n\nNaive Bayes Classifier for Discrete Predictors\n\nCall:\nnaiveBayes.default(x = X, y = Y, laplace = laplace)\n\nA-priori probabilities:\nY\n    Down       Up \n0.491984 0.508016 \n\nConditional probabilities:\n      Lag1\nY             [,1]     [,2]\n  Down  0.04279022 1.227446\n  Up   -0.03954635 1.231668\n\n      Lag2\nY             [,1]     [,2]\n  Down  0.03389409 1.239191\n  Up   -0.03132544 1.220765\n\n\nThe output contains the estimated mean and standard deviation for each variable in each class. For example, the mean for lagone is \\(0.0428\\) for\nDirection=Down, and the standard deviation is \\(1.23\\). We can easily verify this:\n\nmean(Lag1[train][Direction[train] == \"Down\"])\n\n[1] 0.04279022\n\nsd(Lag1[train][Direction[train] == \"Down\"])\n\n[1] 1.227446\n\n\nThe predict() function is straightforward.\n\nnb.class &lt;- predict(nb.fit, Smarket.2005)\ntable(nb.class, Direction.2005)\n\n        Direction.2005\nnb.class Down  Up\n    Down   28  20\n    Up     83 121\n\nmean(nb.class == Direction.2005)\n\n[1] 0.5912698\n\n\nNaive Bayes performs very well on this data, with accurate predictions over \\(59\\%\\) of the time. This is slightly worse than QDA, but much better than LDA.\nThe predict() function can also generate estimates of the probability that each observation belongs to a particular class. %\n\nnb.preds &lt;- predict(nb.fit, Smarket.2005, type = \"raw\")\nnb.preds[1:5, ]\n\n          Down        Up\n[1,] 0.4873164 0.5126836\n[2,] 0.4762492 0.5237508\n[3,] 0.4653377 0.5346623\n[4,] 0.4748652 0.5251348\n[5,] 0.4901890 0.5098110\n\n\n\n\n\nWe will now perform KNN using the knn() function, which is part of the class library. This function works rather differently from the other model-fitting functions that we have encountered thus far. Rather than a two-step approach in which we first fit the model and then we use the model to make predictions, knn() forms predictions using a single command. The function requires four inputs.\n\nA matrix containing the predictors associated with the training data, labeled train.X below.\nA matrix containing the predictors associated with the data for which we wish to make predictions, labeled test.X below.\nA vector containing the class labels for the training observations, labeled train.Direction below.\nA value for \\(K\\), the number of nearest neighbors to be used by the classifier.\n\nWe use the cbind() function, short for column bind, to bind the lagone and lagtwo variables together into two matrices, one for the training set and the other for the test set.\n\nlibrary(class)\ntrain.X &lt;- cbind(Lag1, Lag2)[train, ]\ntest.X &lt;- cbind(Lag1, Lag2)[!train, ]\ntrain.Direction &lt;- Direction[train]\n\nNow the knn() function can be used to predict the market’s movement for the dates in 2005. We set a random seed before we apply knn() because if several observations are tied as nearest neighbors, then R will randomly break the tie. Therefore, a seed must be set in order to ensure reproducibility of results.\n\nset.seed(1)\nknn.pred &lt;- knn(train.X, test.X, train.Direction, k = 1)\ntable(knn.pred, Direction.2005)\n\n        Direction.2005\nknn.pred Down Up\n    Down   43 58\n    Up     68 83\n\n(83 + 43) / 252\n\n[1] 0.5\n\n\nThe results using \\(K=1\\) are not very good, since only \\(50\\) % of the observations are correctly predicted. Of course, it may be that \\(K=1\\) results in an overly flexible fit to the data. Below, we repeat the analysis using \\(K=3\\).\n\nknn.pred &lt;- knn(train.X, test.X, train.Direction, k = 3)\ntable(knn.pred, Direction.2005)\n\n        Direction.2005\nknn.pred Down Up\n    Down   48 54\n    Up     63 87\n\nmean(knn.pred == Direction.2005)\n\n[1] 0.5357143\n\n\nThe results have improved slightly. But increasing \\(K\\) further turns out to provide no further improvements. It appears that for this data, QDA provides the best results of the methods that we have examined so far.\nKNN does not perform well on the Smarket data but it does often provide impressive results. As an example we will apply the KNN approach to the Insurance data set, which is part of the ISLR2 library. This data set includes \\(85\\) predictors that measure demographic characteristics for 5,822 individuals. The response variable is Purchase, which indicates whether or not a given individual purchases a caravan insurance policy. In this data set, only \\(6\\) % of people purchased caravan insurance.\n\ndim(Caravan)\n\n[1] 5822   86\n\nattach(Caravan)\nsummary(Purchase)\n\n  No  Yes \n5474  348 \n\n348 / 5822\n\n[1] 0.05977327\n\n\nBecause the KNN classifier predicts the class of a given test observation by identifying the observations that are nearest to it, the scale of the variables matters. Variables that are on a large scale will have a much larger effect on the distance between the observations, and hence on the KNN classifier, than variables that are on a small scale. For instance, imagine a data set that contains two variables, salary and age (measured in dollars and years, respectively). As far as KNN is concerned, a difference of \\(\\$1,000\\) in salary is enormous compared to a difference of \\(50\\) years in age. Consequently, salary will drive the KNN classification results, and age will have almost no effect. This is contrary to our intuition that a salary difference of \\(\\$1,000\\) is quite small compared to an age difference of \\(50\\) years. Furthermore, the importance of scale to the KNN classifier leads to another issue: if we measured salary in Japanese yen, or if we measured age in minutes, then we’d get quite different classification results from what we get if these two variables are measured in dollars and years.\nA good way to handle this problem is to standardize the data so that all variables are given a mean of zero and a standard deviation of one. Then all variables will be on a comparable scale. The scale() function does just this. In standardizing the data, we exclude column \\(86\\), because that is the qualitative Purchase variable.\n\nstandardized.X &lt;- scale(Caravan[, -86])\nvar(Caravan[, 1])\n\n[1] 165.0378\n\nvar(Caravan[, 2])\n\n[1] 0.1647078\n\nvar(standardized.X[, 1])\n\n[1] 1\n\nvar(standardized.X[, 2])\n\n[1] 1\n\n\nNow every column of standardized.X has a standard deviation of one and a mean of zero.\nWe now split the observations into a test set, containing the first 1,000 observations, and a training set, containing the remaining observations. We fit a KNN model on the training data using \\(K=1\\), and evaluate its performance on the test data.%\n\ntest &lt;- 1:1000\ntrain.X &lt;- standardized.X[-test, ]\ntest.X &lt;- standardized.X[test, ]\ntrain.Y &lt;- Purchase[-test]\ntest.Y &lt;- Purchase[test]\nset.seed(1)\nknn.pred &lt;- knn(train.X, test.X, train.Y, k = 1)\nmean(test.Y != knn.pred)\n\n[1] 0.118\n\nmean(test.Y != \"No\")\n\n[1] 0.059\n\n\nThe vector test is numeric, with values from \\(1\\) through \\(1,000\\). Typing standardized.X[test, ] yields the submatrix of the data containing the observations whose indices range from \\(1\\) to \\(1,000\\), whereas typing\nstandardized.X[-test, ] yields the submatrix containing the observations whose indices do not range from \\(1\\) to \\(1,000\\). The KNN error rate on the 1,000 test observations is just under \\(12\\) %. At first glance, this may appear to be fairly good. However, since only \\(6\\) % of customers purchased insurance, we could get the error rate down to \\(6\\) % by always predicting No regardless of the values of the predictors!\nSuppose that there is some non-trivial cost to trying to sell insurance to a given individual. For instance, perhaps a salesperson must visit each potential customer. If the company tries to sell insurance to a random selection of customers, then the success rate will be only \\(6\\) %, which may be far too low given the costs involved. Instead, the company would like to try to sell insurance only to customers who are likely to buy it. So the overall error rate is not of interest. Instead, the fraction of individuals that are correctly predicted to buy insurance is of interest.\nIt turns out that KNN with \\(K=1\\) does far better than random guessing among the customers that are predicted to buy insurance. Among \\(77\\) such customers, \\(9\\), or \\(11.7\\) %, actually do purchase insurance. This is double the rate that one would obtain from random guessing.\n\ntable(knn.pred, test.Y)\n\n        test.Y\nknn.pred  No Yes\n     No  873  50\n     Yes  68   9\n\n9 / (68 + 9)\n\n[1] 0.1168831\n\n\nUsing \\(K=3\\), the success rate increases to \\(19\\) %, and with \\(K=5\\) the rate is \\(26.7\\) %. This is over four times the rate that results from random guessing. It appears that KNN is finding some real patterns in a difficult data set!\n\nknn.pred &lt;- knn(train.X, test.X, train.Y, k = 3)\ntable(knn.pred, test.Y)\n\n        test.Y\nknn.pred  No Yes\n     No  920  54\n     Yes  21   5\n\n5 / 26\n\n[1] 0.1923077\n\nknn.pred &lt;- knn(train.X, test.X, train.Y, k = 5)\ntable(knn.pred, test.Y)\n\n        test.Y\nknn.pred  No Yes\n     No  930  55\n     Yes  11   4\n\n4 / 15\n\n[1] 0.2666667\n\n\nHowever, while this strategy is cost-effective, it is worth noting that only 15 customers are predicted to purchase insurance using KNN with \\(K=5\\). In practice, the insurance company may wish to expend resources on convincing more than just 15 potential customers to buy insurance.\nAs a comparison, we can also fit a logistic regression model to the data. If we use \\(0.5\\) as the predicted probability cut-off for the classifier, then we have a problem: only seven of the test observations are predicted to purchase insurance. Even worse, we are wrong about all of these! However, we are not required to use a cut-off of \\(0.5\\). If we instead predict a purchase any time the predicted probability of purchase exceeds \\(0.25\\), we get much better results: we predict that 33 people will purchase insurance, and we are correct for about \\(33\\) % of these people. This is over five times better than random guessing!\n\nglm.fits &lt;- glm(Purchase ~ ., data = Caravan,\n    family = binomial, subset = -test)\n\nWarning: glm.fit: fitted probabilities numerically 0 or 1 occurred\n\nglm.probs &lt;- predict(glm.fits, Caravan[test, ],\n    type = \"response\")\nglm.pred &lt;- rep(\"No\", 1000)\nglm.pred[glm.probs &gt; .5] &lt;- \"Yes\"\ntable(glm.pred, test.Y)\n\n        test.Y\nglm.pred  No Yes\n     No  934  59\n     Yes   7   0\n\nglm.pred &lt;- rep(\"No\", 1000)\nglm.pred[glm.probs &gt; .25] &lt;- \"Yes\"\ntable(glm.pred, test.Y)\n\n        test.Y\nglm.pred  No Yes\n     No  919  48\n     Yes  22  11\n\n11 / (22 + 11)\n\n[1] 0.3333333\n\n\n\n\n\nFinally, we fit a Poisson regression model to the Bikeshare data set, which measures the number of bike rentals (bikers) per hour in Washington, DC. The data can be found in the ISLR2 library.\n\nattach(Bikeshare)\ndim(Bikeshare)\n\n[1] 8645   15\n\nnames(Bikeshare)\n\n [1] \"season\"     \"mnth\"       \"day\"        \"hr\"         \"holiday\"   \n [6] \"weekday\"    \"workingday\" \"weathersit\" \"temp\"       \"atemp\"     \n[11] \"hum\"        \"windspeed\"  \"casual\"     \"registered\" \"bikers\"    \n\n\nWe begin by fitting a least squares linear regression model to the data.\n\nmod.lm &lt;- lm(\n    bikers ~ mnth + hr + workingday + temp + weathersit,\n    data = Bikeshare\n  )\nsummary(mod.lm)\n\n\nCall:\nlm(formula = bikers ~ mnth + hr + workingday + temp + weathersit, \n    data = Bikeshare)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-299.00  -45.70   -6.23   41.08  425.29 \n\nCoefficients:\n                          Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)                -68.632      5.307 -12.932  &lt; 2e-16 ***\nmnthFeb                      6.845      4.287   1.597 0.110398    \nmnthMarch                   16.551      4.301   3.848 0.000120 ***\nmnthApril                   41.425      4.972   8.331  &lt; 2e-16 ***\nmnthMay                     72.557      5.641  12.862  &lt; 2e-16 ***\nmnthJune                    67.819      6.544  10.364  &lt; 2e-16 ***\nmnthJuly                    45.324      7.081   6.401 1.63e-10 ***\nmnthAug                     53.243      6.640   8.019 1.21e-15 ***\nmnthSept                    66.678      5.925  11.254  &lt; 2e-16 ***\nmnthOct                     75.834      4.950  15.319  &lt; 2e-16 ***\nmnthNov                     60.310      4.610  13.083  &lt; 2e-16 ***\nmnthDec                     46.458      4.271  10.878  &lt; 2e-16 ***\nhr1                        -14.579      5.699  -2.558 0.010536 *  \nhr2                        -21.579      5.733  -3.764 0.000168 ***\nhr3                        -31.141      5.778  -5.389 7.26e-08 ***\nhr4                        -36.908      5.802  -6.361 2.11e-10 ***\nhr5                        -24.135      5.737  -4.207 2.61e-05 ***\nhr6                         20.600      5.704   3.612 0.000306 ***\nhr7                        120.093      5.693  21.095  &lt; 2e-16 ***\nhr8                        223.662      5.690  39.310  &lt; 2e-16 ***\nhr9                        120.582      5.693  21.182  &lt; 2e-16 ***\nhr10                        83.801      5.705  14.689  &lt; 2e-16 ***\nhr11                       105.423      5.722  18.424  &lt; 2e-16 ***\nhr12                       137.284      5.740  23.916  &lt; 2e-16 ***\nhr13                       136.036      5.760  23.617  &lt; 2e-16 ***\nhr14                       126.636      5.776  21.923  &lt; 2e-16 ***\nhr15                       132.087      5.780  22.852  &lt; 2e-16 ***\nhr16                       178.521      5.772  30.927  &lt; 2e-16 ***\nhr17                       296.267      5.749  51.537  &lt; 2e-16 ***\nhr18                       269.441      5.736  46.976  &lt; 2e-16 ***\nhr19                       186.256      5.714  32.596  &lt; 2e-16 ***\nhr20                       125.549      5.704  22.012  &lt; 2e-16 ***\nhr21                        87.554      5.693  15.378  &lt; 2e-16 ***\nhr22                        59.123      5.689  10.392  &lt; 2e-16 ***\nhr23                        26.838      5.688   4.719 2.41e-06 ***\nworkingday                   1.270      1.784   0.711 0.476810    \ntemp                       157.209     10.261  15.321  &lt; 2e-16 ***\nweathersitcloudy/misty     -12.890      1.964  -6.562 5.60e-11 ***\nweathersitlight rain/snow  -66.494      2.965 -22.425  &lt; 2e-16 ***\nweathersitheavy rain/snow -109.745     76.667  -1.431 0.152341    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 76.5 on 8605 degrees of freedom\nMultiple R-squared:  0.6745,    Adjusted R-squared:  0.6731 \nF-statistic: 457.3 on 39 and 8605 DF,  p-value: &lt; 2.2e-16\n\n\nDue to space constraints, we truncate the output of summary(mod.lm). In mod.lm, the first level of hr (0) and mnth (Jan) are treated as the baseline values, and so no coefficient estimates are provided for them: implicitly, their coefficient estimates are zero, and all other levels are measured relative to these baselines. For example, the Feb coefficient of \\(6.845\\) signifies that, holding all other variables constant, there are on average about 7 more riders in February than in January. Similarly there are about 16.5 more riders in March than in January.\nThe results seen in Section 4.6.1 used a slightly different coding of the variables hr and mnth, as follows:\n\ncontrasts(Bikeshare$hr) = contr.sum(24)\ncontrasts(Bikeshare$mnth) = contr.sum(12)\nmod.lm2 &lt;- lm(\n    bikers ~ mnth + hr + workingday + temp + weathersit,\n    data = Bikeshare\n  )\nsummary(mod.lm2)\n\n\nCall:\nlm(formula = bikers ~ mnth + hr + workingday + temp + weathersit, \n    data = Bikeshare)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-299.00  -45.70   -6.23   41.08  425.29 \n\nCoefficients:\n                           Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)                 73.5974     5.1322  14.340  &lt; 2e-16 ***\nmnth1                      -46.0871     4.0855 -11.281  &lt; 2e-16 ***\nmnth2                      -39.2419     3.5391 -11.088  &lt; 2e-16 ***\nmnth3                      -29.5357     3.1552  -9.361  &lt; 2e-16 ***\nmnth4                       -4.6622     2.7406  -1.701  0.08895 .  \nmnth5                       26.4700     2.8508   9.285  &lt; 2e-16 ***\nmnth6                       21.7317     3.4651   6.272 3.75e-10 ***\nmnth7                       -0.7626     3.9084  -0.195  0.84530    \nmnth8                        7.1560     3.5347   2.024  0.04295 *  \nmnth9                       20.5912     3.0456   6.761 1.46e-11 ***\nmnth10                      29.7472     2.6995  11.019  &lt; 2e-16 ***\nmnth11                      14.2229     2.8604   4.972 6.74e-07 ***\nhr1                        -96.1420     3.9554 -24.307  &lt; 2e-16 ***\nhr2                       -110.7213     3.9662 -27.916  &lt; 2e-16 ***\nhr3                       -117.7212     4.0165 -29.310  &lt; 2e-16 ***\nhr4                       -127.2828     4.0808 -31.191  &lt; 2e-16 ***\nhr5                       -133.0495     4.1168 -32.319  &lt; 2e-16 ***\nhr6                       -120.2775     4.0370 -29.794  &lt; 2e-16 ***\nhr7                        -75.5424     3.9916 -18.925  &lt; 2e-16 ***\nhr8                         23.9511     3.9686   6.035 1.65e-09 ***\nhr9                        127.5199     3.9500  32.284  &lt; 2e-16 ***\nhr10                        24.4399     3.9360   6.209 5.57e-10 ***\nhr11                       -12.3407     3.9361  -3.135  0.00172 ** \nhr12                         9.2814     3.9447   2.353  0.01865 *  \nhr13                        41.1417     3.9571  10.397  &lt; 2e-16 ***\nhr14                        39.8939     3.9750  10.036  &lt; 2e-16 ***\nhr15                        30.4940     3.9910   7.641 2.39e-14 ***\nhr16                        35.9445     3.9949   8.998  &lt; 2e-16 ***\nhr17                        82.3786     3.9883  20.655  &lt; 2e-16 ***\nhr18                       200.1249     3.9638  50.488  &lt; 2e-16 ***\nhr19                       173.2989     3.9561  43.806  &lt; 2e-16 ***\nhr20                        90.1138     3.9400  22.872  &lt; 2e-16 ***\nhr21                        29.4071     3.9362   7.471 8.74e-14 ***\nhr22                        -8.5883     3.9332  -2.184  0.02902 *  \nhr23                       -37.0194     3.9344  -9.409  &lt; 2e-16 ***\nworkingday                   1.2696     1.7845   0.711  0.47681    \ntemp                       157.2094    10.2612  15.321  &lt; 2e-16 ***\nweathersitcloudy/misty     -12.8903     1.9643  -6.562 5.60e-11 ***\nweathersitlight rain/snow  -66.4944     2.9652 -22.425  &lt; 2e-16 ***\nweathersitheavy rain/snow -109.7446    76.6674  -1.431  0.15234    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 76.5 on 8605 degrees of freedom\nMultiple R-squared:  0.6745,    Adjusted R-squared:  0.6731 \nF-statistic: 457.3 on 39 and 8605 DF,  p-value: &lt; 2.2e-16\n\n\nWhat is the difference between the two codings? In mod.lm2, a coefficient estimate is reported for all but the last level of hr and mnth. Importantly, in mod.lm2, the coefficient estimate for the last level of mnth is not zero: instead, it equals the negative of the sum of the coefficient estimates for all of the other levels. Similarly, in mod.lm2, the coefficient estimate for the last level of hr is the negative of the sum of the coefficient estimates for all of the other levels. This means that the coefficients of hr and mnth in mod.lm2 will always sum to zero, and can be interpreted as the difference from the mean level. For example, the coefficient for January of \\(-46.087\\) indicates that, holding all other variables constant, there are typically 46 fewer riders in January relative to the yearly average.\nIt is important to realize that the choice of coding really does not matter, provided that we interpret the model output correctly in light of the coding used. For example, we see that the predictions from the linear model are the same regardless of coding:\n\nsum((predict(mod.lm) - predict(mod.lm2))^2)\n\n[1] 1.586608e-18\n\n\nThe sum of squared differences is zero. We can also see this using the all.equal() function:\n\nall.equal(predict(mod.lm), predict(mod.lm2))\n\n[1] TRUE\n\n\nTo reproduce the left-hand side of Figure 4.13, we must first obtain the coefficient estimates associated with mnth. The coefficients for January through November can be obtained directly from the mod.lm2 object. The coefficient for December must be explicitly computed as the negative sum of all the other months.\n\ncoef.months &lt;- c(coef(mod.lm2)[2:12],\n    -sum(coef(mod.lm2)[2:12]))\n\nTo make the plot, we manually label the \\(x\\)-axis with the names of the months.\n\nplot(coef.months, xlab = \"Month\", ylab = \"Coefficient\",\n    xaxt = \"n\", col = \"blue\", pch = 19, type = \"o\")\naxis(side = 1, at = 1:12, labels = c(\"J\", \"F\", \"M\", \"A\",\n    \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"))\n\n\n\n\n\n\n\n\nReproducing the right-hand side of Figure 4.13 follows a similar process.\n\ncoef.hours &lt;- c(coef(mod.lm2)[13:35],\n    -sum(coef(mod.lm2)[13:35]))\nplot(coef.hours, xlab = \"Hour\", ylab = \"Coefficient\",\n    col = \"blue\", pch = 19, type = \"o\")\n\n\n\n\n\n\n\n\nNow, we consider instead fitting a Poisson regression model to the Bikeshare data. Very little changes, except that we now use the function glm() with the argument family = poisson to specify that we wish to fit a Poisson regression model:\n\nmod.pois &lt;- glm(\n    bikers ~ mnth + hr + workingday + temp + weathersit,\n    data = Bikeshare, family = poisson\n  )\nsummary(mod.pois)\n\n\nCall:\nglm(formula = bikers ~ mnth + hr + workingday + temp + weathersit, \n    family = poisson, data = Bikeshare)\n\nCoefficients:\n                           Estimate Std. Error  z value Pr(&gt;|z|)    \n(Intercept)                4.118245   0.006021  683.964  &lt; 2e-16 ***\nmnth1                     -0.670170   0.005907 -113.445  &lt; 2e-16 ***\nmnth2                     -0.444124   0.004860  -91.379  &lt; 2e-16 ***\nmnth3                     -0.293733   0.004144  -70.886  &lt; 2e-16 ***\nmnth4                      0.021523   0.003125    6.888 5.66e-12 ***\nmnth5                      0.240471   0.002916   82.462  &lt; 2e-16 ***\nmnth6                      0.223235   0.003554   62.818  &lt; 2e-16 ***\nmnth7                      0.103617   0.004125   25.121  &lt; 2e-16 ***\nmnth8                      0.151171   0.003662   41.281  &lt; 2e-16 ***\nmnth9                      0.233493   0.003102   75.281  &lt; 2e-16 ***\nmnth10                     0.267573   0.002785   96.091  &lt; 2e-16 ***\nmnth11                     0.150264   0.003180   47.248  &lt; 2e-16 ***\nhr1                       -0.754386   0.007879  -95.744  &lt; 2e-16 ***\nhr2                       -1.225979   0.009953 -123.173  &lt; 2e-16 ***\nhr3                       -1.563147   0.011869 -131.702  &lt; 2e-16 ***\nhr4                       -2.198304   0.016424 -133.846  &lt; 2e-16 ***\nhr5                       -2.830484   0.022538 -125.586  &lt; 2e-16 ***\nhr6                       -1.814657   0.013464 -134.775  &lt; 2e-16 ***\nhr7                       -0.429888   0.006896  -62.341  &lt; 2e-16 ***\nhr8                        0.575181   0.004406  130.544  &lt; 2e-16 ***\nhr9                        1.076927   0.003563  302.220  &lt; 2e-16 ***\nhr10                       0.581769   0.004286  135.727  &lt; 2e-16 ***\nhr11                       0.336852   0.004720   71.372  &lt; 2e-16 ***\nhr12                       0.494121   0.004392  112.494  &lt; 2e-16 ***\nhr13                       0.679642   0.004069  167.040  &lt; 2e-16 ***\nhr14                       0.673565   0.004089  164.722  &lt; 2e-16 ***\nhr15                       0.624910   0.004178  149.570  &lt; 2e-16 ***\nhr16                       0.653763   0.004132  158.205  &lt; 2e-16 ***\nhr17                       0.874301   0.003784  231.040  &lt; 2e-16 ***\nhr18                       1.294635   0.003254  397.848  &lt; 2e-16 ***\nhr19                       1.212281   0.003321  365.084  &lt; 2e-16 ***\nhr20                       0.914022   0.003700  247.065  &lt; 2e-16 ***\nhr21                       0.616201   0.004191  147.045  &lt; 2e-16 ***\nhr22                       0.364181   0.004659   78.173  &lt; 2e-16 ***\nhr23                       0.117493   0.005225   22.488  &lt; 2e-16 ***\nworkingday                 0.014665   0.001955    7.502 6.27e-14 ***\ntemp                       0.785292   0.011475   68.434  &lt; 2e-16 ***\nweathersitcloudy/misty    -0.075231   0.002179  -34.528  &lt; 2e-16 ***\nweathersitlight rain/snow -0.575800   0.004058 -141.905  &lt; 2e-16 ***\nweathersitheavy rain/snow -0.926287   0.166782   -5.554 2.79e-08 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 1052921  on 8644  degrees of freedom\nResidual deviance:  228041  on 8605  degrees of freedom\nAIC: 281159\n\nNumber of Fisher Scoring iterations: 5\n\n\nWe can plot the coefficients associated with mnth and hr, in order to reproduce Figure 4.15:\n\ncoef.mnth &lt;- c(coef(mod.pois)[2:12],\n    -sum(coef(mod.pois)[2:12]))\nplot(coef.mnth, xlab = \"Month\", ylab = \"Coefficient\",\n     xaxt = \"n\", col = \"blue\", pch = 19, type = \"o\")\naxis(side = 1, at = 1:12, labels = c(\"J\", \"F\", \"M\", \"A\", \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"))\n\n\n\n\n\n\n\ncoef.hours &lt;- c(coef(mod.pois)[13:35],\n     -sum(coef(mod.pois)[13:35]))\nplot(coef.hours, xlab = \"Hour\", ylab = \"Coefficient\",\n    col = \"blue\", pch = 19, type = \"o\")\n\n\n\n\n\n\n\n\nWe can once again use the predict() function to obtain the fitted values (predictions) from this Poisson regression model. However, we must use the argument type = \"response\" to specify that we want R to output \\(\\exp(\\hat\\beta_0 + \\hat\\beta_1 X_1 + \\ldots +\\hat\\beta_p X_p)\\) rather than \\(\\hat\\beta_0 + \\hat\\beta_1 X_1 + \\ldots + \\hat\\beta_p X_p\\), which it will output by default.\n\nplot(predict(mod.lm2), predict(mod.pois, type = \"response\"))\nabline(0, 1, col = 2, lwd = 3)\n\n\n\n\n\n\n\n\nThe predictions from the Poisson regression model are correlated with those from the linear model; however, the former are non-negative. As a result the Poisson regression predictions tend to be larger than those from the linear model for either very low or very high levels of ridership.\nIn this section, we used the glm() function with the argument family = poisson in order to perform Poisson regression. Earlier in this lab we used the glm() function with family = binomial to perform logistic regression. Other choices for the family argument can be used to fit other types of GLMs. For instance, family = Gamma fits a gamma regression model."
  },
  {
    "objectID": "chapter4.html#the-stock-market-data",
    "href": "chapter4.html#the-stock-market-data",
    "title": "chapter4",
    "section": "",
    "text": "We will begin by examining some numerical and graphical summaries of the Smarket data, which is part of the ISLR2 library. This data set consists of percentage returns for the S&P 500 stock index over \\(1,250\\) days, from the beginning of 2001 until the end of 2005. For each date, we have recorded the percentage returns for each of the five previous trading days, lagone through lagfive. We have also recorded volume (the number of shares traded on the previous day, in billions), Today (the percentage return on the date in question) and direction (whether the market was Up or Down on this date). Our goal is to predict direction (a qualitative response) using the other features.\n\nlibrary(ISLR2)\n\nWarning: package 'ISLR2' was built under R version 4.4.1\n\nnames(Smarket)\n\n[1] \"Year\"      \"Lag1\"      \"Lag2\"      \"Lag3\"      \"Lag4\"      \"Lag5\"     \n[7] \"Volume\"    \"Today\"     \"Direction\"\n\ndim(Smarket)\n\n[1] 1250    9\n\nsummary(Smarket)\n\n      Year           Lag1                Lag2                Lag3          \n Min.   :2001   Min.   :-4.922000   Min.   :-4.922000   Min.   :-4.922000  \n 1st Qu.:2002   1st Qu.:-0.639500   1st Qu.:-0.639500   1st Qu.:-0.640000  \n Median :2003   Median : 0.039000   Median : 0.039000   Median : 0.038500  \n Mean   :2003   Mean   : 0.003834   Mean   : 0.003919   Mean   : 0.001716  \n 3rd Qu.:2004   3rd Qu.: 0.596750   3rd Qu.: 0.596750   3rd Qu.: 0.596750  \n Max.   :2005   Max.   : 5.733000   Max.   : 5.733000   Max.   : 5.733000  \n      Lag4                Lag5              Volume           Today          \n Min.   :-4.922000   Min.   :-4.92200   Min.   :0.3561   Min.   :-4.922000  \n 1st Qu.:-0.640000   1st Qu.:-0.64000   1st Qu.:1.2574   1st Qu.:-0.639500  \n Median : 0.038500   Median : 0.03850   Median :1.4229   Median : 0.038500  \n Mean   : 0.001636   Mean   : 0.00561   Mean   :1.4783   Mean   : 0.003138  \n 3rd Qu.: 0.596750   3rd Qu.: 0.59700   3rd Qu.:1.6417   3rd Qu.: 0.596750  \n Max.   : 5.733000   Max.   : 5.73300   Max.   :3.1525   Max.   : 5.733000  \n Direction \n Down:602  \n Up  :648  \n           \n           \n           \n           \n\npairs(Smarket)\n\n\n\n\n\n\n\n\nThe cor() function produces a matrix that contains all of the pairwise correlations among the predictors in a data set. The first command below gives an error message because the direction variable is qualitative.\n\ncor(Smarket)\n\nError in cor(Smarket): 'x' must be numeric\n\ncor(Smarket[, -9])\n\n             Year         Lag1         Lag2         Lag3         Lag4\nYear   1.00000000  0.029699649  0.030596422  0.033194581  0.035688718\nLag1   0.02969965  1.000000000 -0.026294328 -0.010803402 -0.002985911\nLag2   0.03059642 -0.026294328  1.000000000 -0.025896670 -0.010853533\nLag3   0.03319458 -0.010803402 -0.025896670  1.000000000 -0.024051036\nLag4   0.03568872 -0.002985911 -0.010853533 -0.024051036  1.000000000\nLag5   0.02978799 -0.005674606 -0.003557949 -0.018808338 -0.027083641\nVolume 0.53900647  0.040909908 -0.043383215 -0.041823686 -0.048414246\nToday  0.03009523 -0.026155045 -0.010250033 -0.002447647 -0.006899527\n               Lag5      Volume        Today\nYear    0.029787995  0.53900647  0.030095229\nLag1   -0.005674606  0.04090991 -0.026155045\nLag2   -0.003557949 -0.04338321 -0.010250033\nLag3   -0.018808338 -0.04182369 -0.002447647\nLag4   -0.027083641 -0.04841425 -0.006899527\nLag5    1.000000000 -0.02200231 -0.034860083\nVolume -0.022002315  1.00000000  0.014591823\nToday  -0.034860083  0.01459182  1.000000000\n\n\nAs one would expect, the correlations between the lag variables and today’s returns are close to zero. In other words, there appears to be little correlation between today’s returns and previous days’ returns. The only substantial correlation is between Year and volume. By plotting the data, which is ordered chronologically, we see that volume is increasing over time. In other words, the average number of shares traded daily increased from 2001 to 2005.\n\nattach(Smarket)\nplot(Volume)"
  },
  {
    "objectID": "chapter4.html#logistic-regression",
    "href": "chapter4.html#logistic-regression",
    "title": "chapter4",
    "section": "",
    "text": "Next, we will fit a logistic regression model in order to predict direction using lagone through lagfive and volume. The glm() function can be used to fit many types of generalized linear models, including logistic regression. The syntax of the glm() function is similar to that of lm(), except that we must pass in the argument family = binomial in order to tell R to run a logistic regression rather than some other type of generalized linear model.\n\nglm.fits &lt;- glm(\n    Direction ~ Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + Volume,\n    data = Smarket, family = binomial\n  )\nsummary(glm.fits)\n\n\nCall:\nglm(formula = Direction ~ Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + \n    Volume, family = binomial, data = Smarket)\n\nCoefficients:\n             Estimate Std. Error z value Pr(&gt;|z|)\n(Intercept) -0.126000   0.240736  -0.523    0.601\nLag1        -0.073074   0.050167  -1.457    0.145\nLag2        -0.042301   0.050086  -0.845    0.398\nLag3         0.011085   0.049939   0.222    0.824\nLag4         0.009359   0.049974   0.187    0.851\nLag5         0.010313   0.049511   0.208    0.835\nVolume       0.135441   0.158360   0.855    0.392\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 1731.2  on 1249  degrees of freedom\nResidual deviance: 1727.6  on 1243  degrees of freedom\nAIC: 1741.6\n\nNumber of Fisher Scoring iterations: 3\n\n\nThe smallest \\(p\\)-value here is associated with lagone. The negative coefficient for this predictor suggests that if the market had a positive return yesterday, then it is less likely to go up today. However, at a value of \\(0.15\\), the \\(p\\)-value is still relatively large, and so there is no clear evidence of a real association between lagone and direction.\nWe use the coef() function in order to access just the coefficients for this fitted model. We can also use the summary() function to access particular aspects of the fitted model, such as the \\(p\\)-values for the coefficients.\n\ncoef(glm.fits)\n\n (Intercept)         Lag1         Lag2         Lag3         Lag4         Lag5 \n-0.126000257 -0.073073746 -0.042301344  0.011085108  0.009358938  0.010313068 \n      Volume \n 0.135440659 \n\nsummary(glm.fits)$coef\n\n                Estimate Std. Error    z value  Pr(&gt;|z|)\n(Intercept) -0.126000257 0.24073574 -0.5233966 0.6006983\nLag1        -0.073073746 0.05016739 -1.4565986 0.1452272\nLag2        -0.042301344 0.05008605 -0.8445733 0.3983491\nLag3         0.011085108 0.04993854  0.2219750 0.8243333\nLag4         0.009358938 0.04997413  0.1872757 0.8514445\nLag5         0.010313068 0.04951146  0.2082966 0.8349974\nVolume       0.135440659 0.15835970  0.8552723 0.3924004\n\nsummary(glm.fits)$coef[, 4]\n\n(Intercept)        Lag1        Lag2        Lag3        Lag4        Lag5 \n  0.6006983   0.1452272   0.3983491   0.8243333   0.8514445   0.8349974 \n     Volume \n  0.3924004 \n\n\nThe predict() function can be used to predict the probability that the market will go up, given values of the predictors. The type = \"response\" option tells R to output probabilities of the form \\(P(Y=1|X)\\), as opposed to other information such as the logit. If no data set is supplied to the predict() function, then the probabilities are computed for the training data that was used to fit the logistic regression model. Here we have printed only the first ten probabilities. We know that these values correspond to the probability of the market going up, rather than down, because the contrasts() function indicates that R has created a dummy variable with a 1 for Up.\n\nglm.probs &lt;- predict(glm.fits, type = \"response\")\nglm.probs[1:10]\n\n        1         2         3         4         5         6         7         8 \n0.5070841 0.4814679 0.4811388 0.5152224 0.5107812 0.5069565 0.4926509 0.5092292 \n        9        10 \n0.5176135 0.4888378 \n\ncontrasts(Direction)\n\n     Up\nDown  0\nUp    1\n\n\nIn order to make a prediction as to whether the market will go up or down on a particular day, we must convert these predicted probabilities into class labels, Up or Down. The following two commands create a vector of class predictions based on whether the predicted probability of a market increase is greater than or less than \\(0.5\\).\n\nglm.pred &lt;- rep(\"Down\", 1250)\nglm.pred[glm.probs &gt; .5] = \"Up\"\n\nThe first command creates a vector of 1,250 Down elements. The second line transforms to Up all of the elements for which the predicted probability of a market increase exceeds \\(0.5\\). Given these predictions, the table() function can be used to produce a confusion matrix in order to determine how many observations were correctly or incorrectly classified.\n\ntable(glm.pred, Direction)\n\n        Direction\nglm.pred Down  Up\n    Down  145 141\n    Up    457 507\n\n(507 + 145) / 1250\n\n[1] 0.5216\n\nmean(glm.pred == Direction)\n\n[1] 0.5216\n\n\nThe diagonal elements of the confusion matrix indicate correct predictions, while the off-diagonals represent incorrect predictions. Hence our model correctly predicted that the market would go up on \\(507\\) days and that it would go down on \\(145\\) days, for a total of \\(507+145 = 652\\) correct predictions. The mean() function can be used to compute the fraction of days for which the prediction was correct. In this case, logistic regression correctly predicted the movement of the market \\(52.2\\) % of the time.\nAt first glance, it appears that the logistic regression model is working a little better than random guessing. However, this result is misleading because we trained and tested the model on the same set of \\(1,250\\) observations. In other words, \\(100\\%-52.2\\%=47.8\\%\\), is the training error rate. As we have seen previously, the training error rate is often overly optimistic—it tends to underestimate the test error rate. In order to better assess the accuracy of the logistic regression model in this setting, we can fit the model using part of the data, and then examine how well it predicts the held out data. This will yield a more realistic error rate, in the sense that in practice we will be interested in our model’s performance not on the data that we used to fit the model, but rather on days in the future for which the market’s movements are unknown.\nTo implement this strategy, we will first create a vector corresponding to the observations from 2001 through 2004. We will then use this vector to create a held out data set of observations from 2005.\n\ntrain &lt;- (Year &lt; 2005)\nSmarket.2005 &lt;- Smarket[!train, ]\ndim(Smarket.2005)\n\n[1] 252   9\n\nDirection.2005 &lt;- Direction[!train]\n\nThe object train is a vector of \\(1{,}250\\) elements, corresponding to the observations in our data set. The elements of the vector that correspond to observations that occurred before 2005 are set to TRUE, whereas those that correspond to observations in 2005 are set to FALSE. The object train is a Boolean vector, since its elements are TRUE and FALSE. Boolean vectors can be used to obtain a subset of the rows or columns of a matrix. For instance, the command Smarket[train, ] would pick out a submatrix of the stock market data set, corresponding only to the dates before 2005, since those are the ones for which the elements of train are TRUE. The ! symbol can be used to reverse all of the elements of a Boolean vector. That is, !train is a vector similar to train, except that the elements that are TRUE in train get swapped to FALSE in !train, and the elements that are FALSE in train get swapped to TRUE in !train. Therefore, Smarket[!train, ] yields a submatrix of the stock market data containing only the observations for which train is FALSE—that is, the observations with dates in 2005. The output above indicates that there are 252 such observations.\nWe now fit a logistic regression model using only the subset of the observations that correspond to dates before 2005, using the subset argument. We then obtain predicted probabilities of the stock market going up for each of the days in our test set—that is, for the days in 2005.\n\nglm.fits &lt;- glm(\n    Direction ~ Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + Volume,\n    data = Smarket, family = binomial, subset = train\n  )\nglm.probs &lt;- predict(glm.fits, Smarket.2005,\n    type = \"response\")\n\nNotice that we have trained and tested our model on two completely separate data sets: training was performed using only the dates before 2005, and testing was performed using only the dates in 2005. Finally, we compute the predictions for 2005 and compare them to the actual movements of the market over that time period.\n\nglm.pred &lt;- rep(\"Down\", 252)\nglm.pred[glm.probs &gt; .5] &lt;- \"Up\"\ntable(glm.pred, Direction.2005)\n\n        Direction.2005\nglm.pred Down Up\n    Down   77 97\n    Up     34 44\n\nmean(glm.pred == Direction.2005)\n\n[1] 0.4801587\n\nmean(glm.pred != Direction.2005)\n\n[1] 0.5198413\n\n\nThe != notation means not equal to, and so the last command computes the test set error rate. The results are rather disappointing: the test error rate is \\(52\\) %, which is worse than random guessing! Of course this result is not all that surprising, given that one would not generally expect to be able to use previous days’ returns to predict future market performance. (After all, if it were possible to do so, then the authors of this book would be out striking it rich rather than writing a statistics textbook.)\nWe recall that the logistic regression model had very underwhelming \\(p\\)-values associated with all of the predictors, and that the smallest \\(p\\)-value, though not very small, corresponded to lagone. Perhaps by removing the variables that appear not to be helpful in predicting direction, we can obtain a more effective model. After all, using predictors that have no relationship with the response tends to cause a deterioration in the test error rate (since such predictors cause an increase in variance without a corresponding decrease in bias), and so removing such predictors may in turn yield an improvement. Below we have refit the logistic regression using just lagone and lagtwo, which seemed to have the highest predictive power in the original logistic regression model.\n\nglm.fits &lt;- glm(Direction ~ Lag1 + Lag2, data = Smarket,\n    family = binomial, subset = train)\nglm.probs &lt;- predict(glm.fits, Smarket.2005,\n    type = \"response\")\nglm.pred &lt;- rep(\"Down\", 252)\nglm.pred[glm.probs &gt; .5] &lt;- \"Up\"\ntable(glm.pred, Direction.2005)\n\n        Direction.2005\nglm.pred Down  Up\n    Down   35  35\n    Up     76 106\n\nmean(glm.pred == Direction.2005)\n\n[1] 0.5595238\n\n106 / (106 + 76)\n\n[1] 0.5824176\n\n\nNow the results appear to be a little better: \\(56\\%\\) of the daily movements have been correctly predicted. It is worth noting that in this case, a much simpler strategy of predicting that the market will increase every day will also be correct \\(56\\%\\) of the time! Hence, in terms of overall error rate, the logistic regression method is no better than the naive approach. However, the confusion matrix shows that on days when logistic regression predicts an increase in the market, it has a \\(58\\%\\) accuracy rate. This suggests a possible trading strategy of buying on days when the model predicts an increasing market, and avoiding trades on days when a decrease is predicted. Of course one would need to investigate more carefully whether this small improvement was real or just due to random chance.\nSuppose that we want to predict the returns associated with particular values of lagone and lagtwo. In particular, we want to predict direction on a day when lagone and lagtwo equal 1.2 and~1.1, respectively, and on a day when they equal 1.5 and $-$0.8. We do this using the predict() function.\n\npredict(glm.fits,\n    newdata =\n      data.frame(Lag1 = c(1.2, 1.5),  Lag2 = c(1.1, -0.8)),\n    type = \"response\"\n  )\n\n        1         2 \n0.4791462 0.4960939"
  },
  {
    "objectID": "chapter4.html#linear-discriminant-analysis",
    "href": "chapter4.html#linear-discriminant-analysis",
    "title": "chapter4",
    "section": "",
    "text": "Now we will perform LDA on the Smarket data. In R, we fit an LDA model using the lda() function, which is part of the MASS library. Notice that the syntax for the lda() function is identical to that of lm(), and to that of glm() except for the absence of the family option. We fit the model using only the observations before 2005.\n\nlibrary(MASS)\n\n\nAttaching package: 'MASS'\n\n\nThe following object is masked from 'package:ISLR2':\n\n    Boston\n\nlda.fit &lt;- lda(Direction ~ Lag1 + Lag2, data = Smarket,\n    subset = train)\nlda.fit\n\nCall:\nlda(Direction ~ Lag1 + Lag2, data = Smarket, subset = train)\n\nPrior probabilities of groups:\n    Down       Up \n0.491984 0.508016 \n\nGroup means:\n            Lag1        Lag2\nDown  0.04279022  0.03389409\nUp   -0.03954635 -0.03132544\n\nCoefficients of linear discriminants:\n            LD1\nLag1 -0.6420190\nLag2 -0.5135293\n\nplot(lda.fit)\n\n\n\n\n\n\n\n\nThe LDA output indicates that \\(\\hat\\pi_1=0.492\\) and \\(\\hat\\pi_2=0.508\\); in other words, \\(49.2\\) % of the training observations correspond to days during which the market went down. It also provides the group means; these are the average of each predictor within each class, and are used by LDA as estimates of \\(\\mu_k\\). These suggest that there is a tendency for the previous 2~days’ returns to be negative on days when the market increases, and a tendency for the previous days’ returns to be positive on days when the market declines. The coefficients of linear discriminants output provides the linear combination of lagone and lagtwo that are used to form the LDA decision rule. In other words, these are the multipliers of the elements of \\(X=x\\) in (4.24). If $-0.642 \\(`lagone`\\) - 0.514 $lagtwo is large, then the LDA classifier will predict a market increase, and if it is small, then the LDA classifier will predict a market decline.\nThe plot() function produces plots of the linear discriminants, obtained by computing $-0.642 \\(`lagone`\\) - 0.514 $lagtwo for each of the training observations. The Up and Down observations are displayed separately.\nThe predict() function returns a list with three elements. The first element, class, contains LDA’s predictions about the movement of the market. The second element, posterior, is a matrix whose \\(k\\)th column contains the posterior probability that the corresponding observation belongs to the \\(k\\)th class, computed from (4.15). Finally, x contains the linear discriminants, described earlier.\n\nlda.pred &lt;- predict(lda.fit, Smarket.2005)\nnames(lda.pred)\n\n[1] \"class\"     \"posterior\" \"x\"        \n\n\nAs we observed in Section 4.5, the LDA and logistic regression predictions are almost identical.\n\nlda.class &lt;- lda.pred$class\ntable(lda.class, Direction.2005)\n\n         Direction.2005\nlda.class Down  Up\n     Down   35  35\n     Up     76 106\n\nmean(lda.class == Direction.2005)\n\n[1] 0.5595238\n\n\nApplying a \\(50\\) % threshold to the posterior probabilities allows us to recreate the predictions contained in lda.pred$class.\n\nsum(lda.pred$posterior[, 1] &gt;= .5)\n\n[1] 70\n\nsum(lda.pred$posterior[, 1] &lt; .5)\n\n[1] 182\n\n\nNotice that the posterior probability output by the model corresponds to the probability that the market will decrease:\n\nlda.pred$posterior[1:20, 1]\n\n      999      1000      1001      1002      1003      1004      1005      1006 \n0.4901792 0.4792185 0.4668185 0.4740011 0.4927877 0.4938562 0.4951016 0.4872861 \n     1007      1008      1009      1010      1011      1012      1013      1014 \n0.4907013 0.4844026 0.4906963 0.5119988 0.4895152 0.4706761 0.4744593 0.4799583 \n     1015      1016      1017      1018 \n0.4935775 0.5030894 0.4978806 0.4886331 \n\nlda.class[1:20]\n\n [1] Up   Up   Up   Up   Up   Up   Up   Up   Up   Up   Up   Down Up   Up   Up  \n[16] Up   Up   Down Up   Up  \nLevels: Down Up\n\n\nIf we wanted to use a posterior probability threshold other than \\(50\\) % in order to make predictions, then we could easily do so. For instance, suppose that we wish to predict a market decrease only if we are very certain that the market will indeed decrease on that day—say, if the posterior probability is at least \\(90\\) %.\n\nsum(lda.pred$posterior[, 1] &gt; .9)\n\n[1] 0\n\n\nNo days in 2005 meet that threshold! In fact, the greatest posterior probability of decrease in all of 2005 was \\(52.02\\) %."
  },
  {
    "objectID": "chapter4.html#quadratic-discriminant-analysis",
    "href": "chapter4.html#quadratic-discriminant-analysis",
    "title": "chapter4",
    "section": "",
    "text": "We will now fit a QDA model to the Smarket data. QDA is implemented in R using the qda() function, which is also part of the MASS library. The syntax is identical to that of lda().\n\nqda.fit &lt;- qda(Direction ~ Lag1 + Lag2, data = Smarket,\n    subset = train)\nqda.fit\n\nCall:\nqda(Direction ~ Lag1 + Lag2, data = Smarket, subset = train)\n\nPrior probabilities of groups:\n    Down       Up \n0.491984 0.508016 \n\nGroup means:\n            Lag1        Lag2\nDown  0.04279022  0.03389409\nUp   -0.03954635 -0.03132544\n\n\nThe output contains the group means. But it does not contain the coefficients of the linear discriminants, because the QDA classifier involves a quadratic, rather than a linear, function of the predictors. The predict() function works in exactly the same fashion as for LDA.\n\nqda.class &lt;- predict(qda.fit, Smarket.2005)$class\ntable(qda.class, Direction.2005)\n\n         Direction.2005\nqda.class Down  Up\n     Down   30  20\n     Up     81 121\n\nmean(qda.class == Direction.2005)\n\n[1] 0.5992063\n\n\nInterestingly, the QDA predictions are accurate almost \\(60\\) % of the time, even though the 2005 data was not used to fit the model. This level of accuracy is quite impressive for stock market data, which is known to be quite hard to model accurately. This suggests that the quadratic form assumed by QDA may capture the true relationship more accurately than the linear forms assumed by LDA and logistic regression. However, we recommend evaluating this method’s performance on a larger test set before betting that this approach will consistently beat the market!"
  },
  {
    "objectID": "chapter4.html#naive-bayes",
    "href": "chapter4.html#naive-bayes",
    "title": "chapter4",
    "section": "",
    "text": "Next, we fit a naive Bayes model to the Smarket data. Naive Bayes is implemented in R using the naiveBayes() function, which is part of the e1071 library. The syntax is identical to that of lda() and qda(). By default, this implementation of the naive Bayes classifier models each quantitative feature using a Gaussian distribution. However, a kernel density method can also be used to estimate the distributions.\n\nlibrary(e1071)\nnb.fit &lt;- naiveBayes(Direction ~ Lag1 + Lag2, data = Smarket,\n    subset = train)\nnb.fit\n\n\nNaive Bayes Classifier for Discrete Predictors\n\nCall:\nnaiveBayes.default(x = X, y = Y, laplace = laplace)\n\nA-priori probabilities:\nY\n    Down       Up \n0.491984 0.508016 \n\nConditional probabilities:\n      Lag1\nY             [,1]     [,2]\n  Down  0.04279022 1.227446\n  Up   -0.03954635 1.231668\n\n      Lag2\nY             [,1]     [,2]\n  Down  0.03389409 1.239191\n  Up   -0.03132544 1.220765\n\n\nThe output contains the estimated mean and standard deviation for each variable in each class. For example, the mean for lagone is \\(0.0428\\) for\nDirection=Down, and the standard deviation is \\(1.23\\). We can easily verify this:\n\nmean(Lag1[train][Direction[train] == \"Down\"])\n\n[1] 0.04279022\n\nsd(Lag1[train][Direction[train] == \"Down\"])\n\n[1] 1.227446\n\n\nThe predict() function is straightforward.\n\nnb.class &lt;- predict(nb.fit, Smarket.2005)\ntable(nb.class, Direction.2005)\n\n        Direction.2005\nnb.class Down  Up\n    Down   28  20\n    Up     83 121\n\nmean(nb.class == Direction.2005)\n\n[1] 0.5912698\n\n\nNaive Bayes performs very well on this data, with accurate predictions over \\(59\\%\\) of the time. This is slightly worse than QDA, but much better than LDA.\nThe predict() function can also generate estimates of the probability that each observation belongs to a particular class. %\n\nnb.preds &lt;- predict(nb.fit, Smarket.2005, type = \"raw\")\nnb.preds[1:5, ]\n\n          Down        Up\n[1,] 0.4873164 0.5126836\n[2,] 0.4762492 0.5237508\n[3,] 0.4653377 0.5346623\n[4,] 0.4748652 0.5251348\n[5,] 0.4901890 0.5098110"
  },
  {
    "objectID": "chapter4.html#k-nearest-neighbors",
    "href": "chapter4.html#k-nearest-neighbors",
    "title": "chapter4",
    "section": "",
    "text": "We will now perform KNN using the knn() function, which is part of the class library. This function works rather differently from the other model-fitting functions that we have encountered thus far. Rather than a two-step approach in which we first fit the model and then we use the model to make predictions, knn() forms predictions using a single command. The function requires four inputs.\n\nA matrix containing the predictors associated with the training data, labeled train.X below.\nA matrix containing the predictors associated with the data for which we wish to make predictions, labeled test.X below.\nA vector containing the class labels for the training observations, labeled train.Direction below.\nA value for \\(K\\), the number of nearest neighbors to be used by the classifier.\n\nWe use the cbind() function, short for column bind, to bind the lagone and lagtwo variables together into two matrices, one for the training set and the other for the test set.\n\nlibrary(class)\ntrain.X &lt;- cbind(Lag1, Lag2)[train, ]\ntest.X &lt;- cbind(Lag1, Lag2)[!train, ]\ntrain.Direction &lt;- Direction[train]\n\nNow the knn() function can be used to predict the market’s movement for the dates in 2005. We set a random seed before we apply knn() because if several observations are tied as nearest neighbors, then R will randomly break the tie. Therefore, a seed must be set in order to ensure reproducibility of results.\n\nset.seed(1)\nknn.pred &lt;- knn(train.X, test.X, train.Direction, k = 1)\ntable(knn.pred, Direction.2005)\n\n        Direction.2005\nknn.pred Down Up\n    Down   43 58\n    Up     68 83\n\n(83 + 43) / 252\n\n[1] 0.5\n\n\nThe results using \\(K=1\\) are not very good, since only \\(50\\) % of the observations are correctly predicted. Of course, it may be that \\(K=1\\) results in an overly flexible fit to the data. Below, we repeat the analysis using \\(K=3\\).\n\nknn.pred &lt;- knn(train.X, test.X, train.Direction, k = 3)\ntable(knn.pred, Direction.2005)\n\n        Direction.2005\nknn.pred Down Up\n    Down   48 54\n    Up     63 87\n\nmean(knn.pred == Direction.2005)\n\n[1] 0.5357143\n\n\nThe results have improved slightly. But increasing \\(K\\) further turns out to provide no further improvements. It appears that for this data, QDA provides the best results of the methods that we have examined so far.\nKNN does not perform well on the Smarket data but it does often provide impressive results. As an example we will apply the KNN approach to the Insurance data set, which is part of the ISLR2 library. This data set includes \\(85\\) predictors that measure demographic characteristics for 5,822 individuals. The response variable is Purchase, which indicates whether or not a given individual purchases a caravan insurance policy. In this data set, only \\(6\\) % of people purchased caravan insurance.\n\ndim(Caravan)\n\n[1] 5822   86\n\nattach(Caravan)\nsummary(Purchase)\n\n  No  Yes \n5474  348 \n\n348 / 5822\n\n[1] 0.05977327\n\n\nBecause the KNN classifier predicts the class of a given test observation by identifying the observations that are nearest to it, the scale of the variables matters. Variables that are on a large scale will have a much larger effect on the distance between the observations, and hence on the KNN classifier, than variables that are on a small scale. For instance, imagine a data set that contains two variables, salary and age (measured in dollars and years, respectively). As far as KNN is concerned, a difference of \\(\\$1,000\\) in salary is enormous compared to a difference of \\(50\\) years in age. Consequently, salary will drive the KNN classification results, and age will have almost no effect. This is contrary to our intuition that a salary difference of \\(\\$1,000\\) is quite small compared to an age difference of \\(50\\) years. Furthermore, the importance of scale to the KNN classifier leads to another issue: if we measured salary in Japanese yen, or if we measured age in minutes, then we’d get quite different classification results from what we get if these two variables are measured in dollars and years.\nA good way to handle this problem is to standardize the data so that all variables are given a mean of zero and a standard deviation of one. Then all variables will be on a comparable scale. The scale() function does just this. In standardizing the data, we exclude column \\(86\\), because that is the qualitative Purchase variable.\n\nstandardized.X &lt;- scale(Caravan[, -86])\nvar(Caravan[, 1])\n\n[1] 165.0378\n\nvar(Caravan[, 2])\n\n[1] 0.1647078\n\nvar(standardized.X[, 1])\n\n[1] 1\n\nvar(standardized.X[, 2])\n\n[1] 1\n\n\nNow every column of standardized.X has a standard deviation of one and a mean of zero.\nWe now split the observations into a test set, containing the first 1,000 observations, and a training set, containing the remaining observations. We fit a KNN model on the training data using \\(K=1\\), and evaluate its performance on the test data.%\n\ntest &lt;- 1:1000\ntrain.X &lt;- standardized.X[-test, ]\ntest.X &lt;- standardized.X[test, ]\ntrain.Y &lt;- Purchase[-test]\ntest.Y &lt;- Purchase[test]\nset.seed(1)\nknn.pred &lt;- knn(train.X, test.X, train.Y, k = 1)\nmean(test.Y != knn.pred)\n\n[1] 0.118\n\nmean(test.Y != \"No\")\n\n[1] 0.059\n\n\nThe vector test is numeric, with values from \\(1\\) through \\(1,000\\). Typing standardized.X[test, ] yields the submatrix of the data containing the observations whose indices range from \\(1\\) to \\(1,000\\), whereas typing\nstandardized.X[-test, ] yields the submatrix containing the observations whose indices do not range from \\(1\\) to \\(1,000\\). The KNN error rate on the 1,000 test observations is just under \\(12\\) %. At first glance, this may appear to be fairly good. However, since only \\(6\\) % of customers purchased insurance, we could get the error rate down to \\(6\\) % by always predicting No regardless of the values of the predictors!\nSuppose that there is some non-trivial cost to trying to sell insurance to a given individual. For instance, perhaps a salesperson must visit each potential customer. If the company tries to sell insurance to a random selection of customers, then the success rate will be only \\(6\\) %, which may be far too low given the costs involved. Instead, the company would like to try to sell insurance only to customers who are likely to buy it. So the overall error rate is not of interest. Instead, the fraction of individuals that are correctly predicted to buy insurance is of interest.\nIt turns out that KNN with \\(K=1\\) does far better than random guessing among the customers that are predicted to buy insurance. Among \\(77\\) such customers, \\(9\\), or \\(11.7\\) %, actually do purchase insurance. This is double the rate that one would obtain from random guessing.\n\ntable(knn.pred, test.Y)\n\n        test.Y\nknn.pred  No Yes\n     No  873  50\n     Yes  68   9\n\n9 / (68 + 9)\n\n[1] 0.1168831\n\n\nUsing \\(K=3\\), the success rate increases to \\(19\\) %, and with \\(K=5\\) the rate is \\(26.7\\) %. This is over four times the rate that results from random guessing. It appears that KNN is finding some real patterns in a difficult data set!\n\nknn.pred &lt;- knn(train.X, test.X, train.Y, k = 3)\ntable(knn.pred, test.Y)\n\n        test.Y\nknn.pred  No Yes\n     No  920  54\n     Yes  21   5\n\n5 / 26\n\n[1] 0.1923077\n\nknn.pred &lt;- knn(train.X, test.X, train.Y, k = 5)\ntable(knn.pred, test.Y)\n\n        test.Y\nknn.pred  No Yes\n     No  930  55\n     Yes  11   4\n\n4 / 15\n\n[1] 0.2666667\n\n\nHowever, while this strategy is cost-effective, it is worth noting that only 15 customers are predicted to purchase insurance using KNN with \\(K=5\\). In practice, the insurance company may wish to expend resources on convincing more than just 15 potential customers to buy insurance.\nAs a comparison, we can also fit a logistic regression model to the data. If we use \\(0.5\\) as the predicted probability cut-off for the classifier, then we have a problem: only seven of the test observations are predicted to purchase insurance. Even worse, we are wrong about all of these! However, we are not required to use a cut-off of \\(0.5\\). If we instead predict a purchase any time the predicted probability of purchase exceeds \\(0.25\\), we get much better results: we predict that 33 people will purchase insurance, and we are correct for about \\(33\\) % of these people. This is over five times better than random guessing!\n\nglm.fits &lt;- glm(Purchase ~ ., data = Caravan,\n    family = binomial, subset = -test)\n\nWarning: glm.fit: fitted probabilities numerically 0 or 1 occurred\n\nglm.probs &lt;- predict(glm.fits, Caravan[test, ],\n    type = \"response\")\nglm.pred &lt;- rep(\"No\", 1000)\nglm.pred[glm.probs &gt; .5] &lt;- \"Yes\"\ntable(glm.pred, test.Y)\n\n        test.Y\nglm.pred  No Yes\n     No  934  59\n     Yes   7   0\n\nglm.pred &lt;- rep(\"No\", 1000)\nglm.pred[glm.probs &gt; .25] &lt;- \"Yes\"\ntable(glm.pred, test.Y)\n\n        test.Y\nglm.pred  No Yes\n     No  919  48\n     Yes  22  11\n\n11 / (22 + 11)\n\n[1] 0.3333333"
  },
  {
    "objectID": "chapter4.html#poisson-regression",
    "href": "chapter4.html#poisson-regression",
    "title": "chapter4",
    "section": "",
    "text": "Finally, we fit a Poisson regression model to the Bikeshare data set, which measures the number of bike rentals (bikers) per hour in Washington, DC. The data can be found in the ISLR2 library.\n\nattach(Bikeshare)\ndim(Bikeshare)\n\n[1] 8645   15\n\nnames(Bikeshare)\n\n [1] \"season\"     \"mnth\"       \"day\"        \"hr\"         \"holiday\"   \n [6] \"weekday\"    \"workingday\" \"weathersit\" \"temp\"       \"atemp\"     \n[11] \"hum\"        \"windspeed\"  \"casual\"     \"registered\" \"bikers\"    \n\n\nWe begin by fitting a least squares linear regression model to the data.\n\nmod.lm &lt;- lm(\n    bikers ~ mnth + hr + workingday + temp + weathersit,\n    data = Bikeshare\n  )\nsummary(mod.lm)\n\n\nCall:\nlm(formula = bikers ~ mnth + hr + workingday + temp + weathersit, \n    data = Bikeshare)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-299.00  -45.70   -6.23   41.08  425.29 \n\nCoefficients:\n                          Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)                -68.632      5.307 -12.932  &lt; 2e-16 ***\nmnthFeb                      6.845      4.287   1.597 0.110398    \nmnthMarch                   16.551      4.301   3.848 0.000120 ***\nmnthApril                   41.425      4.972   8.331  &lt; 2e-16 ***\nmnthMay                     72.557      5.641  12.862  &lt; 2e-16 ***\nmnthJune                    67.819      6.544  10.364  &lt; 2e-16 ***\nmnthJuly                    45.324      7.081   6.401 1.63e-10 ***\nmnthAug                     53.243      6.640   8.019 1.21e-15 ***\nmnthSept                    66.678      5.925  11.254  &lt; 2e-16 ***\nmnthOct                     75.834      4.950  15.319  &lt; 2e-16 ***\nmnthNov                     60.310      4.610  13.083  &lt; 2e-16 ***\nmnthDec                     46.458      4.271  10.878  &lt; 2e-16 ***\nhr1                        -14.579      5.699  -2.558 0.010536 *  \nhr2                        -21.579      5.733  -3.764 0.000168 ***\nhr3                        -31.141      5.778  -5.389 7.26e-08 ***\nhr4                        -36.908      5.802  -6.361 2.11e-10 ***\nhr5                        -24.135      5.737  -4.207 2.61e-05 ***\nhr6                         20.600      5.704   3.612 0.000306 ***\nhr7                        120.093      5.693  21.095  &lt; 2e-16 ***\nhr8                        223.662      5.690  39.310  &lt; 2e-16 ***\nhr9                        120.582      5.693  21.182  &lt; 2e-16 ***\nhr10                        83.801      5.705  14.689  &lt; 2e-16 ***\nhr11                       105.423      5.722  18.424  &lt; 2e-16 ***\nhr12                       137.284      5.740  23.916  &lt; 2e-16 ***\nhr13                       136.036      5.760  23.617  &lt; 2e-16 ***\nhr14                       126.636      5.776  21.923  &lt; 2e-16 ***\nhr15                       132.087      5.780  22.852  &lt; 2e-16 ***\nhr16                       178.521      5.772  30.927  &lt; 2e-16 ***\nhr17                       296.267      5.749  51.537  &lt; 2e-16 ***\nhr18                       269.441      5.736  46.976  &lt; 2e-16 ***\nhr19                       186.256      5.714  32.596  &lt; 2e-16 ***\nhr20                       125.549      5.704  22.012  &lt; 2e-16 ***\nhr21                        87.554      5.693  15.378  &lt; 2e-16 ***\nhr22                        59.123      5.689  10.392  &lt; 2e-16 ***\nhr23                        26.838      5.688   4.719 2.41e-06 ***\nworkingday                   1.270      1.784   0.711 0.476810    \ntemp                       157.209     10.261  15.321  &lt; 2e-16 ***\nweathersitcloudy/misty     -12.890      1.964  -6.562 5.60e-11 ***\nweathersitlight rain/snow  -66.494      2.965 -22.425  &lt; 2e-16 ***\nweathersitheavy rain/snow -109.745     76.667  -1.431 0.152341    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 76.5 on 8605 degrees of freedom\nMultiple R-squared:  0.6745,    Adjusted R-squared:  0.6731 \nF-statistic: 457.3 on 39 and 8605 DF,  p-value: &lt; 2.2e-16\n\n\nDue to space constraints, we truncate the output of summary(mod.lm). In mod.lm, the first level of hr (0) and mnth (Jan) are treated as the baseline values, and so no coefficient estimates are provided for them: implicitly, their coefficient estimates are zero, and all other levels are measured relative to these baselines. For example, the Feb coefficient of \\(6.845\\) signifies that, holding all other variables constant, there are on average about 7 more riders in February than in January. Similarly there are about 16.5 more riders in March than in January.\nThe results seen in Section 4.6.1 used a slightly different coding of the variables hr and mnth, as follows:\n\ncontrasts(Bikeshare$hr) = contr.sum(24)\ncontrasts(Bikeshare$mnth) = contr.sum(12)\nmod.lm2 &lt;- lm(\n    bikers ~ mnth + hr + workingday + temp + weathersit,\n    data = Bikeshare\n  )\nsummary(mod.lm2)\n\n\nCall:\nlm(formula = bikers ~ mnth + hr + workingday + temp + weathersit, \n    data = Bikeshare)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-299.00  -45.70   -6.23   41.08  425.29 \n\nCoefficients:\n                           Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)                 73.5974     5.1322  14.340  &lt; 2e-16 ***\nmnth1                      -46.0871     4.0855 -11.281  &lt; 2e-16 ***\nmnth2                      -39.2419     3.5391 -11.088  &lt; 2e-16 ***\nmnth3                      -29.5357     3.1552  -9.361  &lt; 2e-16 ***\nmnth4                       -4.6622     2.7406  -1.701  0.08895 .  \nmnth5                       26.4700     2.8508   9.285  &lt; 2e-16 ***\nmnth6                       21.7317     3.4651   6.272 3.75e-10 ***\nmnth7                       -0.7626     3.9084  -0.195  0.84530    \nmnth8                        7.1560     3.5347   2.024  0.04295 *  \nmnth9                       20.5912     3.0456   6.761 1.46e-11 ***\nmnth10                      29.7472     2.6995  11.019  &lt; 2e-16 ***\nmnth11                      14.2229     2.8604   4.972 6.74e-07 ***\nhr1                        -96.1420     3.9554 -24.307  &lt; 2e-16 ***\nhr2                       -110.7213     3.9662 -27.916  &lt; 2e-16 ***\nhr3                       -117.7212     4.0165 -29.310  &lt; 2e-16 ***\nhr4                       -127.2828     4.0808 -31.191  &lt; 2e-16 ***\nhr5                       -133.0495     4.1168 -32.319  &lt; 2e-16 ***\nhr6                       -120.2775     4.0370 -29.794  &lt; 2e-16 ***\nhr7                        -75.5424     3.9916 -18.925  &lt; 2e-16 ***\nhr8                         23.9511     3.9686   6.035 1.65e-09 ***\nhr9                        127.5199     3.9500  32.284  &lt; 2e-16 ***\nhr10                        24.4399     3.9360   6.209 5.57e-10 ***\nhr11                       -12.3407     3.9361  -3.135  0.00172 ** \nhr12                         9.2814     3.9447   2.353  0.01865 *  \nhr13                        41.1417     3.9571  10.397  &lt; 2e-16 ***\nhr14                        39.8939     3.9750  10.036  &lt; 2e-16 ***\nhr15                        30.4940     3.9910   7.641 2.39e-14 ***\nhr16                        35.9445     3.9949   8.998  &lt; 2e-16 ***\nhr17                        82.3786     3.9883  20.655  &lt; 2e-16 ***\nhr18                       200.1249     3.9638  50.488  &lt; 2e-16 ***\nhr19                       173.2989     3.9561  43.806  &lt; 2e-16 ***\nhr20                        90.1138     3.9400  22.872  &lt; 2e-16 ***\nhr21                        29.4071     3.9362   7.471 8.74e-14 ***\nhr22                        -8.5883     3.9332  -2.184  0.02902 *  \nhr23                       -37.0194     3.9344  -9.409  &lt; 2e-16 ***\nworkingday                   1.2696     1.7845   0.711  0.47681    \ntemp                       157.2094    10.2612  15.321  &lt; 2e-16 ***\nweathersitcloudy/misty     -12.8903     1.9643  -6.562 5.60e-11 ***\nweathersitlight rain/snow  -66.4944     2.9652 -22.425  &lt; 2e-16 ***\nweathersitheavy rain/snow -109.7446    76.6674  -1.431  0.15234    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 76.5 on 8605 degrees of freedom\nMultiple R-squared:  0.6745,    Adjusted R-squared:  0.6731 \nF-statistic: 457.3 on 39 and 8605 DF,  p-value: &lt; 2.2e-16\n\n\nWhat is the difference between the two codings? In mod.lm2, a coefficient estimate is reported for all but the last level of hr and mnth. Importantly, in mod.lm2, the coefficient estimate for the last level of mnth is not zero: instead, it equals the negative of the sum of the coefficient estimates for all of the other levels. Similarly, in mod.lm2, the coefficient estimate for the last level of hr is the negative of the sum of the coefficient estimates for all of the other levels. This means that the coefficients of hr and mnth in mod.lm2 will always sum to zero, and can be interpreted as the difference from the mean level. For example, the coefficient for January of \\(-46.087\\) indicates that, holding all other variables constant, there are typically 46 fewer riders in January relative to the yearly average.\nIt is important to realize that the choice of coding really does not matter, provided that we interpret the model output correctly in light of the coding used. For example, we see that the predictions from the linear model are the same regardless of coding:\n\nsum((predict(mod.lm) - predict(mod.lm2))^2)\n\n[1] 1.586608e-18\n\n\nThe sum of squared differences is zero. We can also see this using the all.equal() function:\n\nall.equal(predict(mod.lm), predict(mod.lm2))\n\n[1] TRUE\n\n\nTo reproduce the left-hand side of Figure 4.13, we must first obtain the coefficient estimates associated with mnth. The coefficients for January through November can be obtained directly from the mod.lm2 object. The coefficient for December must be explicitly computed as the negative sum of all the other months.\n\ncoef.months &lt;- c(coef(mod.lm2)[2:12],\n    -sum(coef(mod.lm2)[2:12]))\n\nTo make the plot, we manually label the \\(x\\)-axis with the names of the months.\n\nplot(coef.months, xlab = \"Month\", ylab = \"Coefficient\",\n    xaxt = \"n\", col = \"blue\", pch = 19, type = \"o\")\naxis(side = 1, at = 1:12, labels = c(\"J\", \"F\", \"M\", \"A\",\n    \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"))\n\n\n\n\n\n\n\n\nReproducing the right-hand side of Figure 4.13 follows a similar process.\n\ncoef.hours &lt;- c(coef(mod.lm2)[13:35],\n    -sum(coef(mod.lm2)[13:35]))\nplot(coef.hours, xlab = \"Hour\", ylab = \"Coefficient\",\n    col = \"blue\", pch = 19, type = \"o\")\n\n\n\n\n\n\n\n\nNow, we consider instead fitting a Poisson regression model to the Bikeshare data. Very little changes, except that we now use the function glm() with the argument family = poisson to specify that we wish to fit a Poisson regression model:\n\nmod.pois &lt;- glm(\n    bikers ~ mnth + hr + workingday + temp + weathersit,\n    data = Bikeshare, family = poisson\n  )\nsummary(mod.pois)\n\n\nCall:\nglm(formula = bikers ~ mnth + hr + workingday + temp + weathersit, \n    family = poisson, data = Bikeshare)\n\nCoefficients:\n                           Estimate Std. Error  z value Pr(&gt;|z|)    \n(Intercept)                4.118245   0.006021  683.964  &lt; 2e-16 ***\nmnth1                     -0.670170   0.005907 -113.445  &lt; 2e-16 ***\nmnth2                     -0.444124   0.004860  -91.379  &lt; 2e-16 ***\nmnth3                     -0.293733   0.004144  -70.886  &lt; 2e-16 ***\nmnth4                      0.021523   0.003125    6.888 5.66e-12 ***\nmnth5                      0.240471   0.002916   82.462  &lt; 2e-16 ***\nmnth6                      0.223235   0.003554   62.818  &lt; 2e-16 ***\nmnth7                      0.103617   0.004125   25.121  &lt; 2e-16 ***\nmnth8                      0.151171   0.003662   41.281  &lt; 2e-16 ***\nmnth9                      0.233493   0.003102   75.281  &lt; 2e-16 ***\nmnth10                     0.267573   0.002785   96.091  &lt; 2e-16 ***\nmnth11                     0.150264   0.003180   47.248  &lt; 2e-16 ***\nhr1                       -0.754386   0.007879  -95.744  &lt; 2e-16 ***\nhr2                       -1.225979   0.009953 -123.173  &lt; 2e-16 ***\nhr3                       -1.563147   0.011869 -131.702  &lt; 2e-16 ***\nhr4                       -2.198304   0.016424 -133.846  &lt; 2e-16 ***\nhr5                       -2.830484   0.022538 -125.586  &lt; 2e-16 ***\nhr6                       -1.814657   0.013464 -134.775  &lt; 2e-16 ***\nhr7                       -0.429888   0.006896  -62.341  &lt; 2e-16 ***\nhr8                        0.575181   0.004406  130.544  &lt; 2e-16 ***\nhr9                        1.076927   0.003563  302.220  &lt; 2e-16 ***\nhr10                       0.581769   0.004286  135.727  &lt; 2e-16 ***\nhr11                       0.336852   0.004720   71.372  &lt; 2e-16 ***\nhr12                       0.494121   0.004392  112.494  &lt; 2e-16 ***\nhr13                       0.679642   0.004069  167.040  &lt; 2e-16 ***\nhr14                       0.673565   0.004089  164.722  &lt; 2e-16 ***\nhr15                       0.624910   0.004178  149.570  &lt; 2e-16 ***\nhr16                       0.653763   0.004132  158.205  &lt; 2e-16 ***\nhr17                       0.874301   0.003784  231.040  &lt; 2e-16 ***\nhr18                       1.294635   0.003254  397.848  &lt; 2e-16 ***\nhr19                       1.212281   0.003321  365.084  &lt; 2e-16 ***\nhr20                       0.914022   0.003700  247.065  &lt; 2e-16 ***\nhr21                       0.616201   0.004191  147.045  &lt; 2e-16 ***\nhr22                       0.364181   0.004659   78.173  &lt; 2e-16 ***\nhr23                       0.117493   0.005225   22.488  &lt; 2e-16 ***\nworkingday                 0.014665   0.001955    7.502 6.27e-14 ***\ntemp                       0.785292   0.011475   68.434  &lt; 2e-16 ***\nweathersitcloudy/misty    -0.075231   0.002179  -34.528  &lt; 2e-16 ***\nweathersitlight rain/snow -0.575800   0.004058 -141.905  &lt; 2e-16 ***\nweathersitheavy rain/snow -0.926287   0.166782   -5.554 2.79e-08 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 1052921  on 8644  degrees of freedom\nResidual deviance:  228041  on 8605  degrees of freedom\nAIC: 281159\n\nNumber of Fisher Scoring iterations: 5\n\n\nWe can plot the coefficients associated with mnth and hr, in order to reproduce Figure 4.15:\n\ncoef.mnth &lt;- c(coef(mod.pois)[2:12],\n    -sum(coef(mod.pois)[2:12]))\nplot(coef.mnth, xlab = \"Month\", ylab = \"Coefficient\",\n     xaxt = \"n\", col = \"blue\", pch = 19, type = \"o\")\naxis(side = 1, at = 1:12, labels = c(\"J\", \"F\", \"M\", \"A\", \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"))\n\n\n\n\n\n\n\ncoef.hours &lt;- c(coef(mod.pois)[13:35],\n     -sum(coef(mod.pois)[13:35]))\nplot(coef.hours, xlab = \"Hour\", ylab = \"Coefficient\",\n    col = \"blue\", pch = 19, type = \"o\")\n\n\n\n\n\n\n\n\nWe can once again use the predict() function to obtain the fitted values (predictions) from this Poisson regression model. However, we must use the argument type = \"response\" to specify that we want R to output \\(\\exp(\\hat\\beta_0 + \\hat\\beta_1 X_1 + \\ldots +\\hat\\beta_p X_p)\\) rather than \\(\\hat\\beta_0 + \\hat\\beta_1 X_1 + \\ldots + \\hat\\beta_p X_p\\), which it will output by default.\n\nplot(predict(mod.lm2), predict(mod.pois, type = \"response\"))\nabline(0, 1, col = 2, lwd = 3)\n\n\n\n\n\n\n\n\nThe predictions from the Poisson regression model are correlated with those from the linear model; however, the former are non-negative. As a result the Poisson regression predictions tend to be larger than those from the linear model for either very low or very high levels of ridership.\nIn this section, we used the glm() function with the argument family = poisson in order to perform Poisson regression. Earlier in this lab we used the glm() function with family = binomial to perform logistic regression. Other choices for the family argument can be used to fit other types of GLMs. For instance, family = Gamma fits a gamma regression model."
  }
]